------------------------------
FILE: codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect files from folder respecting ignore rules
 */
function getAllFiles(folderPath, ignoreRules = [], repoRoot) {
    let files = [];
    if (!fs.existsSync(folderPath)) return files;

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);
        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (item.isDirectory()) {
            files = files.concat(getAllFiles(fullPath, ignoreRules, repoRoot));
        } else if (item.isFile()) {
            files.push(fullPath);
        }
    }
    return files;
}

/**
 * Generate combined code output
 * @param {string[]} selectedItems
 * @param {string} outputFile
 * @param {function(number):void} onProgress
 * @param {string} repoRoot
 * @param {string[]} ignoreRules
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}, repoRoot, ignoreRules = []) {
    if (!selectedItems.length) return;
    if (!repoRoot) repoRoot = path.dirname(selectedItems[0]);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles = allFiles.concat(getAllFiles(item, ignoreRules, repoRoot));
        else if (stat.isFile() && !isIgnored(item, repoRoot, ignoreRules)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        writeStream.write(`\n// ===== File: ${path.relative(repoRoot, filePath)} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }
    writeStream.close();
}

module.exports = { generateCode };


------------------------------
FILE: docignore.js

const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch');
const { app } = require('electron');

const globalIgnorePath = path.join(app.getPath('userData'), 'global-docignore.json');

/**
 * Get global ignore rules
 * @returns {string[]}
 */
function getGlobalIgnoreRules() {
    if (!fs.existsSync(globalIgnorePath)) return [];
    try {
        const data = fs.readFileSync(globalIgnorePath, 'utf-8');
        console.log('[Docignore] Global ignore rules loaded:', data);
        return JSON.parse(data);
    } catch (err) {
        console.error('[Docignore] Failed to read global ignore:', err);
        return [];
    }
}

/**
 * Get combined ignore rules for a repo (global + optional repo-specific)
 * @param {string} repoPath
 * @returns {Promise<string[]>}
 */
async function getIgnoreRules(repoPath) {
    try {
        let repoRules = [];
        const repoIgnoreFile = path.join(repoPath, '.docignore');

        if (fs.existsSync(repoIgnoreFile)) {
            const data = fs.readFileSync(repoIgnoreFile, 'utf-8');
            try {
                repoRules = JSON.parse(data);
            } catch (err) {
                console.warn('[Docignore] Failed to parse repo .docignore, skipping:', err.message);
            }
        }

        const combinedRules = [...getGlobalIgnoreRules(), ...repoRules];
        console.log('[Docignore] Combined ignore rules for', repoPath, combinedRules);
        return combinedRules;
    } catch (err) {
        console.error('[Docignore] getIgnoreRules error:', err);
        return [];
    }
}

/**
 * Check if a file/folder is ignored
 * @param {string} fullPath
 * @param {string} repoPath
 * @param {string[]} extraRules Optional extra rules (repo-specific)
 */
function isIgnored(fullPath, repoPath, extraRules = []) {
    const relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');
    const rules = [...getGlobalIgnoreRules(), ...extraRules];
    const ignored = micromatch.isMatch(relPath, rules, { dot: true });
    // debug log
    if (ignored) console.log('[Docignore] Ignored:', relPath);
    return ignored;
}

module.exports = { isIgnored, getGlobalIgnoreRules, getIgnoreRules };


------------------------------
FILE: fileOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored } = require('./docignore');

/**
 * Get folder tree structure for tree view
 */
function getFolderTree(dir, ignoreRules = [], repoRoot = dir) {
    return fs.readdirSync(dir, { withFileTypes: true })
        .filter(f => !isIgnored(path.join(dir, f.name), repoRoot, ignoreRules))
        .map(f => f.isDirectory()
            ? { 
                name: f.name, 
                path: path.join(dir, f.name), 
                type: 'folder', 
                children: getFolderTree(path.join(dir, f.name), ignoreRules, repoRoot) 
              }
            : { name: f.name, path: path.join(dir, f.name), type: 'file' }
        );
}

/**
 * Generate folder structure output (text)
 */
async function generateStructure(selectedPaths, outputFile, ignoreRules = [], progressCallback = () => {}) {
    const outputLines = [];
    const allItems = [];

    function collect(p, repoRoot, depth = 0) {
        if (isIgnored(p, repoRoot, ignoreRules)) return;
        allItems.push({ path: p, depth });
        if (fs.statSync(p).isDirectory()) {
            fs.readdirSync(p).forEach(c => collect(path.join(p, c), repoRoot, depth + 1));
        }
    }

    selectedPaths.forEach(p => collect(p, p));

    allItems.forEach((item, idx) => {
        const stat = fs.statSync(item.path);
        const prefix = '  '.repeat(item.depth);
        outputLines.push(`${prefix}${path.basename(item.path)}${stat.isDirectory() ? '/' : ''}`);
        progressCallback(Math.round(((idx + 1) / allItems.length) * 100));
    });

    fs.writeFileSync(outputFile, outputLines.join('\n'), 'utf-8');
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: treeView.js

/**
 * Tree View Renderer
 * -----------------
 * - Shows folders always
 * - Files shown in code mode
 * - Click to select folders/files
 * - Folder selection in code mode = all files inside selected recursively
 * - Highlights selected items
 * - Displays children in horizontal rows (flex)
 */
export function renderTree(treeData, container, selectedItems, actionType, onToggle) {
    container.innerHTML = '';

    // Store expanded/collapsed folder state
    const expandedFolders = new WeakMap();

    // Recursively get all files under a folder
    function getAllFiles(node) {
        if (node.type === 'file') return [node];
        if (!node.children?.length) return [];
        return node.children.flatMap(getAllFiles);
    }

    function createNode(node) {
        // In structure mode, skip files
        if (actionType === 'structure' && node.type === 'file') return null;

        const el = document.createElement('div');
        el.classList.add('tree-node');
        if (node.type === 'file') el.classList.add('file');
        else el.classList.add('folder');

        // Determine if node is selected
        const isSelected = selectedItems.includes(node.path);

        // Apply highlight
        if (node.type === 'folder' && actionType === 'code' && isSelected) el.classList.add('folder-selected');
        else if (node.type === 'file' && isSelected) el.classList.add('file-selected');
        else if (node.type === 'folder' && isSelected) el.classList.add('selected');

        // Label
        let label = node.name;
        if (node.type === 'folder' && node.children?.length && actionType !== 'structure') {
            const fileCount = countFiles(node);
            if (fileCount > 0) label += ` (${fileCount} files)`;
        }
        if (node.type === 'folder' && actionType === 'code' && isSelected) label += ' [ALL FILES]';
        el.textContent = label;

        // Children container
        let childrenContainer;
        if (node.type === 'folder' && node.children?.length) {
            childrenContainer = document.createElement('div');
            childrenContainer.classList.add('children');
            // Use flex + wrap for horizontal layout
            childrenContainer.style.display = expandedFolders.get(node) ? 'flex' : 'none';
            childrenContainer.style.flexWrap = 'wrap';
            childrenContainer.style.gap = '8px';
            childrenContainer.style.marginLeft = '20px';

            node.children.forEach(child => {
                const childNode = createNode(child);
                if (childNode) childrenContainer.appendChild(childNode);
            });

            el.appendChild(childrenContainer);
        }

        // Click logic
        el.addEventListener('click', e => {
            e.stopPropagation();

            // Toggle selection
            if (node.type === 'file') {
                const index = selectedItems.indexOf(node.path);
                if (index === -1) selectedItems.push(node.path);
                else selectedItems.splice(index, 1);
            } else if (node.type === 'folder') {
                if (actionType === 'code') {
                    const allFiles = getAllFiles(node);
                    const allSelected = allFiles.every(f => selectedItems.includes(f.path));
                    if (allSelected) {
                        allFiles.forEach(f => {
                            const idx = selectedItems.indexOf(f.path);
                            if (idx !== -1) selectedItems.splice(idx, 1);
                        });
                    } else {
                        allFiles.forEach(f => {
                            if (!selectedItems.includes(f.path)) selectedItems.push(f.path);
                        });
                    }
                } else {
                    // Structure mode: toggle folder only
                    const idx = selectedItems.indexOf(node.path);
                    if (idx === -1) selectedItems.push(node.path);
                    else selectedItems.splice(idx, 1);
                }
            }

            // Folder expand/collapse
            if (node.type === 'folder') {
                const isExpanded = expandedFolders.get(node) || false;
                expandedFolders.set(node, !isExpanded);
                if (childrenContainer) childrenContainer.style.display = !isExpanded ? 'flex' : 'none';
                el.classList.toggle('folder-open', !isExpanded);
            }

            // Force re-render to update highlights
            renderTree(treeData, container, selectedItems, actionType, onToggle);

            // Trigger callback
            if (onToggle) onToggle(node);
        });

        return el;
    }

    treeData.forEach(node => {
        const n = createNode(node);
        if (n) container.appendChild(n);
    });
}

// Count files recursively
function countFiles(node) {
    if (node.type === 'file') return 1;
    if (!node.children?.length) return 0;
    return node.children.reduce((acc, child) => acc + countFiles(child), 0);
}


