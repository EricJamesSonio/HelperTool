------------------------------
FILE: codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect files from folder respecting ignore rules
 * Skips entire ignored folders
 */
function getAllFiles(folderPath, repoRoot) {
    if (isIgnored(folderPath, repoRoot)) return [];

    if (!fs.existsSync(folderPath)) return [];

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    let files = [];

    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        if (isIgnored(fullPath, repoRoot)) continue;

        if (item.isDirectory()) files.push(...getAllFiles(fullPath, repoRoot));
        else files.push(fullPath);
    }

    return files;
}

/**
 * Find repo root starting from a folder (optional fallback)
 */
function findRepoRoot(startPath) {
    let dir = path.resolve(startPath);
    while (dir && dir !== path.parse(dir).root) {
        if (fs.existsSync(path.join(dir, '.docignore')) || fs.existsSync(path.join(dir, 'package.json'))) {
            return dir;
        }
        dir = path.dirname(dir);
    }
    return startPath; // fallback to the folder itself
}

/**
 * Generate combined code output from selected items
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}) {
    if (!selectedItems.length) return;

    const repoRoot = path.resolve(selectedItems[0]);
    await getIgnoreRules(repoRoot); // load & cache rules

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles.push(...getAllFiles(item, repoRoot));
        else if (!isIgnored(item, repoRoot)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        const relativeName = path.relative(repoRoot, filePath) || path.basename(filePath);
        writeStream.write(`\n// ===== File: ${relativeName} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }

    writeStream.close();
}

/**
 * Get folder tree structure for tree view respecting ignore rules
 * FIXED: Now properly awaits all nested folder promises
 */
async function getFolderTree(dir, repoRoot = null) {
    if (!repoRoot) repoRoot = path.resolve(dir);
    await getIgnoreRules(repoRoot);

    if (isIgnored(dir, repoRoot)) return [];

    let entries = [];
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
        return [];
    }

    // Filter out ignored entries first
    const validEntries = entries.filter(entry => 
        !isIgnored(path.join(dir, entry.name), repoRoot)
    );

    // Process all entries and await promises
    const results = await Promise.all(
        validEntries.map(async (entry) => {
            const fullPath = path.join(dir, entry.name);
            
            if (entry.isDirectory()) {
                // Recursively get children (await the promise!)
                const children = await getFolderTree(fullPath, repoRoot);
                return {
                    name: entry.name,
                    path: fullPath,
                    type: 'folder',
                    children: children,
                };
            }
            
            return { 
                name: entry.name, 
                path: fullPath, 
                type: 'file' 
            };
        })
    );

    return results;
}

module.exports = { generateCode, getAllFiles, findRepoRoot, getFolderTree };

------------------------------
FILE: docignore.js

// file: docignore.js
const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch');
const { app } = require('electron');

const globalIgnorePath = path.join(app.getPath('userData'), 'global-docignore.json');

// ----------------------------
// Cached Global Rules
// ----------------------------
let cachedGlobalRules = null;
const repoRulesCache = new Map();        // repo path -> combined rules
const compiledMatchersCache = new Map(); // repo path -> compiled matcher functions

function loadGlobalIgnoreRules() {
    if (cachedGlobalRules) return cachedGlobalRules;

    if (!fs.existsSync(globalIgnorePath)) {
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }

    try {
        cachedGlobalRules = JSON.parse(fs.readFileSync(globalIgnorePath, 'utf-8'));
        console.log('[Docignore] Global ignore rules loaded:', cachedGlobalRules);
        return cachedGlobalRules;
    } catch (err) {
        console.error('[Docignore] Failed to read global ignore:', err);
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }
}

// ----------------------------
// Repo-specific + combined rules (cached)
// ----------------------------
async function getIgnoreRules(repoPath) {
    if (repoRulesCache.has(repoPath)) return repoRulesCache.get(repoPath);

    let repoRules = [];
    const repoIgnoreFile = path.join(repoPath, '.docignore');

    if (fs.existsSync(repoIgnoreFile)) {
        try {
            repoRules = JSON.parse(fs.readFileSync(repoIgnoreFile, 'utf-8'));
        } catch (err) {
            console.warn('[Docignore] Failed to parse repo .docignore:', err.message);
        }
    }

    const combinedRules = [...loadGlobalIgnoreRules(), ...repoRules];
    repoRulesCache.set(repoPath, combinedRules);

    // Precompile matchers for this repo
    const matchers = combinedRules.map(pattern => micromatch.matcher(pattern, { dot: true }));
    compiledMatchersCache.set(repoPath, matchers);

    return combinedRules;
}

// ----------------------------
// Check if path is ignored
// ----------------------------
function isIgnored(fullPath, repoPath) {
    if (!repoPath) return false;

    let relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');

    // Ignore anything outside the repo
    if (relPath.startsWith('..')) return false;

    const matchers = compiledMatchersCache.get(repoPath) || [];
    return matchers.some(fn => fn(relPath));
}

module.exports = { isIgnored, loadGlobalIgnoreRules, getIgnoreRules };


------------------------------
FILE: fileOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively get folder tree structure for tree view
 */
async function getFolderTree(dir, ignoreRules = [], repoRoot) {
    if (!repoRoot) repoRoot = path.resolve(dir);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    if (isIgnored(dir, repoRoot, ignoreRules)) return [];

    let entries;
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch (err) {
        return [];
    }

    const tree = [];
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (entry.isDirectory()) {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'folder',
                children: await getFolderTree(fullPath, ignoreRules, repoRoot),
            });
        } else {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'file',
            });
        }
    }

    return tree;
}

/**
 * Generate tree-style structure text respecting repo ignore rules
 * with progress updates
 */
async function generateStructure(selectedPaths, outputFile, ignoreRules = [], progressCallback = () => {}) {
    if (!selectedPaths || !selectedPaths.length) return;

    const repoRoot = path.resolve(selectedPaths[0]);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    // Helper: build tree nodes recursively
    async function buildTree(currentPath) {
        if (isIgnored(currentPath, repoRoot, ignoreRules)) return null;

        let stat;
        try { stat = fs.statSync(currentPath); } catch { return null; }

        const node = {
            name: path.basename(currentPath),
            path: currentPath,
            type: stat.isDirectory() ? 'folder' : 'file',
            children: []
        };

        if (stat.isDirectory()) {
            const entries = fs.readdirSync(currentPath);
            for (const entry of entries) {
                const childNode = await buildTree(path.join(currentPath, entry));
                if (childNode) node.children.push(childNode);
            }
        }

        return node;
    }

    // Helper: convert tree node to text lines
    function treeLines(node, prefix = '', isLast = true, isRoot = true) {
        const lines = [];
        const connector = isRoot ? '' : (isLast ? '└─ ' : '├─ ');
        lines.push(prefix + connector + node.name + (node.type === 'folder' ? '/' : ''));

        if (node.children && node.children.length > 0) {
            node.children.forEach((child, idx) => {
                const last = idx === node.children.length - 1;
                const newPrefix = prefix + (isRoot ? '' : (isLast ? '    ' : '│   '));
                lines.push(...treeLines(child, newPrefix, last, false));
            });
        }

        return lines;
    }

    const allLines = [];
    for (let i = 0; i < selectedPaths.length; i++) {
        const p = selectedPaths[i];
        const rootNode = await buildTree(p);
        if (rootNode) allLines.push(...treeLines(rootNode));

        // Incremental progress per root path
        const percent = Math.round(((i + 1) / selectedPaths.length) * 100);
        progressCallback(percent);
    }

    // Write to file
    try {
        fs.writeFileSync(outputFile, allLines.join('\n'), 'utf-8');
        progressCallback(100); // ensure 100% at end
    } catch (err) {
        console.error('[generateStructure] Failed to write file:', err);
    }
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: treeView.js

/**
 * Tree Diagram Renderer (Refactored)
 * ---------------------------------
 * - Pure render: selection comes ONLY from selectedItems
 * - No re-render on click
 * - Stable selection & expansion behavior
 */

export function renderTree(treeData, container, selectedItems, actionType, onToggle) {
    container.innerHTML = '';

    /* ----------------------------------------
     * Persistent folder expansion state
     * -------------------------------------- */
    if (!window._expandedFolders) {
        window._expandedFolders = new Map();
    }
    const expandedFolders = window._expandedFolders;

    /* ----------------------------------------
     * Helpers (PURE)
     * -------------------------------------- */

    const getAllFiles = (node) => {
        if (node.type === 'file') return [node];
        if (!node.children) return [];
        return node.children.flatMap(getAllFiles);
    };

    const countFiles = (node) => {
        if (node.type === 'file') return 1;
        if (!node.children) return 0;
        return node.children.reduce((sum, c) => sum + countFiles(c), 0);
    };

    const isSelected = (path) => selectedItems.includes(path);

    /* ----------------------------------------
     * DOM helpers
     * -------------------------------------- */

    function applySelectionClass(el, node) {
        el.classList.remove('selected', 'folder-selected', 'file-selected');

        if (!isSelected(node.path)) return;

        if (node.type === 'folder') {
            if (actionType === 'code') el.classList.add('folder-selected');
            else el.classList.add('selected');
        } else {
            el.classList.add('file-selected');
        }
    }

    function updateAllSelectionHighlights() {
        container.querySelectorAll('.tree-node').forEach(el => {
            const wrapper = el.parentElement;
            if (!wrapper?.dataset.nodePath) return;

            const path = wrapper.dataset.nodePath;
            const type = el.classList.contains('folder') ? 'folder' : 'file';

            applySelectionClass(el, { path, type });
        });

        updateGenerateState();
    }

    function updateGenerateState() {
        const btn = document.getElementById('generateBtn');
        if (btn) btn.disabled = selectedItems.length === 0;
    }

    /* ----------------------------------------
     * Node creation
     * -------------------------------------- */

    function createNode(node, depth = 0) {
        if (actionType === 'structure' && node.type === 'file') return null;

        const wrapper = document.createElement('div');
        wrapper.className = 'node-wrapper';
        wrapper.style.setProperty('--depth', depth);
        wrapper.dataset.nodePath = node.path;

        const el = document.createElement('div');
        el.classList.add('tree-node', node.type);

        /* Expansion state (folders only) */
        let expanded = expandedFolders.get(node.path);
        if (expanded === undefined && node.type === 'folder') {
            expanded = true;
            expandedFolders.set(node.path, true);
        }

        if (node.type === 'folder' && node.children?.length) {
            el.classList.add('expandable');
            if (expanded) el.classList.add('folder-open');
        }

        /* Label */
        let label = node.name;

        if (node.type === 'folder' && node.children?.length && actionType !== 'structure') {
            const count = countFiles(node);
            if (count > 0) label += ` (${count})`;
        }

        if (node.type === 'folder' && actionType === 'code' && isSelected(node.path)) {
            label += ' [ALL]';
        }

        el.textContent = label;
        applySelectionClass(el, node);

        wrapper.appendChild(el);

        /* Children */
        let childrenContainer = null;

        if (node.type === 'folder' && node.children?.length) {
            childrenContainer = document.createElement('div');
            childrenContainer.className = 'children';
            if (!expanded) childrenContainer.style.display = 'none';

            node.children.forEach(child => {
                const childEl = createNode(child, depth + 1);
                if (childEl) {
                    childrenContainer.appendChild(childEl);
                }
            });



            wrapper.appendChild(childrenContainer);
        }

        /* ----------------------------------------
         * Click handling (STATE ONLY)
         * -------------------------------------- */
        el.addEventListener('click', (e) => {
            e.stopPropagation();

            if (node.type === 'file') {
                togglePath(node.path);
            } else {
                if (actionType === 'code') {
                    const files = getAllFiles(node);
                    const allSelected = files.every(f => isSelected(f.path));

                    files.forEach(f => {
                        if (allSelected) removePath(f.path);
                        else addPath(f.path);
                    });
                } else {
                    togglePath(node.path);
                }

                if (node.children?.length) {
                    expanded = !expanded;
                    expandedFolders.set(node.path, expanded);

                    if (childrenContainer) {
                        childrenContainer.style.display = expanded ? 'flex' : 'none';
                    }

                    el.classList.toggle('folder-open', expanded);
                }
            }

            updateAllSelectionHighlights();
            onToggle?.(node);
        });

        return wrapper;
    }

    /* ----------------------------------------
     * Selection mutations (CENTRALIZED)
     * -------------------------------------- */

    function addPath(path) {
        if (!selectedItems.includes(path)) selectedItems.push(path);
    }

    function removePath(path) {
        const i = selectedItems.indexOf(path);
        if (i !== -1) selectedItems.splice(i, 1);
    }

    function togglePath(path) {
        if (isSelected(path)) removePath(path);
        else addPath(path);
    }

    /* ----------------------------------------
     * Initial render
     * -------------------------------------- */

    const root = document.createElement('div');
    root.className = 'tree-root';

    treeData.forEach(node => {
        const el = createNode(node, 0);
        if (el) root.appendChild(el);
    });

    container.appendChild(root);
    updateGenerateState();
}


