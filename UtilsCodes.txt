------------------------------
FILE: codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect all file paths from a folder, respecting ignore rules
 */
function getAllFiles(folderPath, ignoreRules = [], repoRoot) {
    let files = [];
    if (!fs.existsSync(folderPath)) return files;

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (item.isDirectory()) {
            files = files.concat(getAllFiles(fullPath, ignoreRules, repoRoot));
        } else if (item.isFile()) {
            files.push(fullPath);
        }
    }

    return files;
}

/**
 * Generate code file by combining multiple selected folders/files
 * @param {Array<string>} selectedItems - files or folders
 * @param {string} outputFile
 * @param {Function} onProgress - callback(percent)
 * @param {string} repoRoot - repo root path
 * @param {Array<string>} ignoreRules - optional ignore rules
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}, repoRoot, ignoreRules = []) {
    if (!selectedItems.length) return;
    if (!repoRoot) repoRoot = path.dirname(selectedItems[0]);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles = allFiles.concat(getAllFiles(item, ignoreRules, repoRoot));
        else if (stat.isFile() && !isIgnored(item, repoRoot, ignoreRules)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        writeStream.write(`\n// ===== File: ${path.relative(repoRoot, filePath)} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }
    writeStream.close();
}


module.exports = {
    generateCode
};


------------------------------
FILE: docignore.js

const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch'); // npm install micromatch

/**
 * Read .docignore file from repo
 * @param {string} repoPath - path to the repo
 * @returns {Promise<string[]>} - array of patterns to ignore
 */
async function getIgnoreRules(repoPath) {
    const cfg = path.join(repoPath, '.docignore');
    if (!fs.existsSync(cfg)) return [];
    return fs.readFileSync(cfg, 'utf-8')
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'));
}


/**
 * Check if a given file/folder path should be ignored
 * @param {string} fullPath - absolute path of file/folder
 * @param {string} repoPath - root repo path
 * @param {Array<string>} ignoreRules - array of patterns from getIgnoreRules
 * @returns {boolean}
 */
function isIgnored(fullPath, repoPath, ignoreRules) {
    const relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');
    return micromatch.isMatch(relPath, ignoreRules, { dot: true });
}
module.exports = { getIgnoreRules, isIgnored };


------------------------------
FILE: fileOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored } = require('./docignore');

function getFolderTree(dir, ignoreRules = [], repoRoot = dir) {
    return fs.readdirSync(dir, { withFileTypes: true })
        .filter(f => !isIgnored(path.join(dir, f.name), repoRoot, ignoreRules))
        .map(f => f.isDirectory()
            ? { name: f.name, path: path.join(dir, f.name), type: 'folder', children: getFolderTree(path.join(dir, f.name), ignoreRules, repoRoot) }
            : { name: f.name, path: path.join(dir, f.name), type: 'file' }
        );
}

async function generateStructure(selectedPaths, outputFile, ignoreRules = [], progressCallback = () => {}) {
    let output = '';
    const allItems = [];

    function collect(p, repoRoot) {
        if (isIgnored(p, repoRoot, ignoreRules)) return;
        allItems.push(p);
        if (fs.statSync(p).isDirectory())
            fs.readdirSync(p).forEach(c => collect(path.join(p, c), repoRoot));
    }

    selectedPaths.forEach(p => collect(p, p));

    allItems.forEach((p, idx) => {
        const stat = fs.statSync(p);
        output += `${'  '.repeat(p.split(path.sep).length)}${path.basename(p)}${stat.isDirectory() ? '/' : ''}\n`;
        progressCallback(Math.round(((idx + 1) / allItems.length) * 100));
    });

    fs.writeFileSync(outputFile, output, 'utf-8');
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: treeView.js



