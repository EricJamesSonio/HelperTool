------------------------------
FILE: codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect files from folder respecting ignore rules
 * Skips entire ignored folders
 */
function getAllFiles(folderPath, repoRoot) {
    if (isIgnored(folderPath, repoRoot)) return [];

    if (!fs.existsSync(folderPath)) return [];

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    let files = [];

    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        if (isIgnored(fullPath, repoRoot)) continue;

        if (item.isDirectory()) files.push(...getAllFiles(fullPath, repoRoot));
        else files.push(fullPath);
    }

    return files;
}

/**
 * Find repo root starting from a folder (optional fallback)
 */
function findRepoRoot(startPath) {
    let dir = path.resolve(startPath);
    while (dir && dir !== path.parse(dir).root) {
        if (fs.existsSync(path.join(dir, '.docignore')) || fs.existsSync(path.join(dir, 'package.json'))) {
            return dir;
        }
        dir = path.dirname(dir);
    }
    return startPath; // fallback to the folder itself
}

/**
 * Generate combined code output from selected items
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}) {
    if (!selectedItems.length) return;

    const repoRoot = path.resolve(selectedItems[0]);
    await getIgnoreRules(repoRoot); // load & cache rules

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles.push(...getAllFiles(item, repoRoot));
        else if (!isIgnored(item, repoRoot)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        writeStream.write(`\n// ===== File: ${path.relative(repoRoot, filePath)} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }
    writeStream.close();
}

/**
 * Get folder tree structure for tree view respecting ignore rules
 * FIXED: Now properly awaits all nested folder promises
 */
async function getFolderTree(dir, repoRoot = null) {
    if (!repoRoot) repoRoot = path.resolve(dir);
    await getIgnoreRules(repoRoot);

    if (isIgnored(dir, repoRoot)) return [];

    let entries = [];
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
        return [];
    }

    // Filter out ignored entries first
    const validEntries = entries.filter(entry => 
        !isIgnored(path.join(dir, entry.name), repoRoot)
    );

    // Process all entries and await promises
    const results = await Promise.all(
        validEntries.map(async (entry) => {
            const fullPath = path.join(dir, entry.name);
            
            if (entry.isDirectory()) {
                // Recursively get children (await the promise!)
                const children = await getFolderTree(fullPath, repoRoot);
                return {
                    name: entry.name,
                    path: fullPath,
                    type: 'folder',
                    children: children,
                };
            }
            
            return { 
                name: entry.name, 
                path: fullPath, 
                type: 'file' 
            };
        })
    );

    return results;
}

module.exports = { generateCode, getAllFiles, findRepoRoot, getFolderTree };

------------------------------
FILE: docignore.js

// file: docignore.js
const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch');
const { app } = require('electron');

const globalIgnorePath = path.join(app.getPath('userData'), 'global-docignore.json');

// ----------------------------
// Cached Global Rules
// ----------------------------
let cachedGlobalRules = null;
const repoRulesCache = new Map();        // repo path -> combined rules
const compiledMatchersCache = new Map(); // repo path -> compiled matcher functions

function loadGlobalIgnoreRules() {
    if (cachedGlobalRules) return cachedGlobalRules;

    if (!fs.existsSync(globalIgnorePath)) {
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }

    try {
        cachedGlobalRules = JSON.parse(fs.readFileSync(globalIgnorePath, 'utf-8'));
        console.log('[Docignore] Global ignore rules loaded:', cachedGlobalRules);
        return cachedGlobalRules;
    } catch (err) {
        console.error('[Docignore] Failed to read global ignore:', err);
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }
}

// ----------------------------
// Repo-specific + combined rules (cached)
// ----------------------------
async function getIgnoreRules(repoPath) {
    if (repoRulesCache.has(repoPath)) return repoRulesCache.get(repoPath);

    let repoRules = [];
    const repoIgnoreFile = path.join(repoPath, '.docignore');

    if (fs.existsSync(repoIgnoreFile)) {
        try {
            repoRules = JSON.parse(fs.readFileSync(repoIgnoreFile, 'utf-8'));
        } catch (err) {
            console.warn('[Docignore] Failed to parse repo .docignore:', err.message);
        }
    }

    const combinedRules = [...loadGlobalIgnoreRules(), ...repoRules];
    repoRulesCache.set(repoPath, combinedRules);

    // Precompile matchers for this repo
    const matchers = combinedRules.map(pattern => micromatch.matcher(pattern, { dot: true }));
    compiledMatchersCache.set(repoPath, matchers);

    return combinedRules;
}

// ----------------------------
// Check if path is ignored
// ----------------------------
function isIgnored(fullPath, repoPath) {
    if (!repoPath) return false;

    let relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');

    // Ignore anything outside the repo
    if (relPath.startsWith('..')) return false;

    const matchers = compiledMatchersCache.get(repoPath) || [];
    return matchers.some(fn => fn(relPath));
}

module.exports = { isIgnored, loadGlobalIgnoreRules, getIgnoreRules };


------------------------------
FILE: fileOps.js

// file: fileOps.js
const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Get folder tree structure for tree view
 * @param {string} dir - starting directory
 * @param {string[]} ignoreRules - optional ignore rules
 * @param {string} repoRoot - repo root path
 */
async function getFolderTree(dir, ignoreRules = [], repoRoot) {
    if (!repoRoot) repoRoot = path.resolve(dir);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    if (isIgnored(dir, repoRoot, ignoreRules)) return [];

    let entries = [];
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch (err) {
        return [];
    }

    const tree = [];
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (entry.isDirectory()) {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'folder',
                children: await getFolderTree(fullPath, ignoreRules, repoRoot),
            });
        } else {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'file',
            });
        }
    }

    return tree;
}

/**
 * Generate folder structure output (text) respecting repo ignore rules
 * @param {string[]} selectedPaths - folders/files selected by user
 * @param {string} outputFile - path to write structure text
 * @param {function(number):void} progressCallback - optional progress update
 */
async function generateStructure(selectedPaths, outputFile, progressCallback = () => {}) {
    if (!selectedPaths || !selectedPaths.length) return;

    // Use the first selected path as repo root
    const repoRoot = path.resolve(selectedPaths[0]);

    // Load ignore rules for this repo
    const ignoreRules = await getIgnoreRules(repoRoot);

    const outputLines = [];
    const allItems = [];

function collect(currentPath, depth = 0) {
    if (isIgnored(currentPath, repoRoot, ignoreRules)) return;

    let stat;
    try { stat = fs.statSync(currentPath); } catch { return; }

    if (stat.isFile() || (stat.isDirectory() && fs.readdirSync(currentPath).length > 0)) {
        allItems.push({ path: currentPath, depth });
    }

    if (stat.isDirectory()) {
        const children = fs.readdirSync(currentPath);
        for (const child of children) {
            collect(path.join(currentPath, child), depth + 1);
        }
    }
}


    selectedPaths.forEach(p => collect(p, 0));

    // Build output lines for folder structure
    allItems.forEach((item, idx) => {
        const stat = fs.statSync(item.path);
        const prefix = '  '.repeat(item.depth);
        outputLines.push(`${prefix}${path.basename(item.path)}${stat.isDirectory() ? '/' : ''}`);

        progressCallback(Math.round(((idx + 1) / allItems.length) * 100));
    });

    fs.writeFileSync(outputFile, outputLines.join('\n'), 'utf-8');
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: treeView.js

/**
 * Tree Diagram Renderer
 * -----------------
 * - Shows folders always
 * - Files shown in code mode
 * - ALL folders expanded by default
 * - Click to select folders/files
 * - Folder selection in code mode = all files inside selected recursively
 * - Highlights selected items
 * - Displays as visual tree with connecting lines
 * - Compact design for easier viewing of large trees
 * - Proper alignment: same depth = same vertical position
 */
export function renderTree(treeData, container, selectedItems, actionType, onToggle) {
    container.innerHTML = '';
    
    // Store expanded/collapsed folder state persistently
    if (!window._expandedFolders) {
        window._expandedFolders = new Map();
    }
    const expandedFolders = window._expandedFolders;

    // Recursively get all files under a folder (ignores folders with no files)
    function getAllFiles(node) {
        if (node.type === 'file') return [node];
        if (!node.children?.length) return [];
        return node.children.flatMap(getAllFiles);
    }

    // Count only visible files recursively
    function countFiles(node) {
        if (node.type === 'file') return 1;
        if (!node.children?.length) return 0;
        return node.children.reduce((acc, child) => acc + countFiles(child), 0);
    }

    // Get maximum depth of tree
    function getMaxDepth(nodes, currentDepth = 0) {
        if (!nodes || nodes.length === 0) return currentDepth;
        let maxChildDepth = currentDepth;
        nodes.forEach(node => {
            if (node.children?.length) {
                const childDepth = getMaxDepth(node.children, currentDepth + 1);
                maxChildDepth = Math.max(maxChildDepth, childDepth);
            }
        });
        return maxChildDepth;
    }

    // Organize nodes by depth level
    function organizeByDepth(nodes, depth = 0, result = {}) {
        if (!result[depth]) result[depth] = [];
        
        nodes.forEach(node => {
            // Skip files in structure mode
            if (actionType === 'structure' && node.type === 'file') return;
            
            result[depth].push(node);
            
            if (node.children?.length) {
                organizeByDepth(node.children, depth + 1, result);
            }
        });
        
        return result;
    }

    function createNode(node, depth = 0) {
        // Skip files in structure mode
        if (actionType === 'structure' && node.type === 'file') return null;

        const nodeWrapper = document.createElement('div');
        nodeWrapper.classList.add('node-wrapper');
        nodeWrapper.style.setProperty('--depth', depth);
        nodeWrapper.dataset.nodePath = node.path;
        nodeWrapper.dataset.nodeDepth = depth;

        const el = document.createElement('div');
        el.classList.add('tree-node');
        if (node.type === 'file') el.classList.add('file');
        else el.classList.add('folder');

        const isSelected = selectedItems.includes(node.path);
        
        // Check if folder should be expanded - DEFAULT TO TRUE for all folders
        let isExpanded = expandedFolders.get(node.path);
        if (isExpanded === undefined && node.type === 'folder' && node.children?.length) {
            isExpanded = true; // Expand all folders by default
            expandedFolders.set(node.path, true);
        }
        isExpanded = isExpanded !== false; // Default to expanded unless explicitly collapsed

        // Highlight selection
        if (node.type === 'folder' && actionType === 'code' && isSelected) el.classList.add('folder-selected');
        else if (node.type === 'file' && isSelected) el.classList.add('file-selected');
        else if (node.type === 'folder' && isSelected) el.classList.add('selected');

        // Add expand indicator for folders with children
        if (node.type === 'folder' && node.children?.length) {
            el.classList.add('expandable');
            if (isExpanded) el.classList.add('folder-open');
        }

        // Label (more compact)
        let label = node.name;
        if (node.type === 'folder' && node.children?.length && actionType !== 'structure') {
            const fileCount = countFiles(node);
            if (fileCount > 0) label += ` (${fileCount})`;
        }
        if (node.type === 'folder' && actionType === 'code' && isSelected) label += ' [ALL]';
        el.textContent = label;

        nodeWrapper.appendChild(el);

        // Children container - ALWAYS render if folder has children
        if (node.type === 'folder' && node.children?.length) {
            const childrenContainer = document.createElement('div');
            childrenContainer.classList.add('children');
            
            // Show/hide based on expanded state (but default is shown)
            if (!isExpanded) {
                childrenContainer.style.display = 'none';
            }

            node.children.forEach(child => {
                const childNode = createNode(child, depth + 1);
                if (childNode) childrenContainer.appendChild(childNode);
            });

            nodeWrapper.appendChild(childrenContainer);
        }

        // Click logic
        el.addEventListener('click', e => {
            e.stopPropagation();

            if (node.type === 'file') {
                const index = selectedItems.indexOf(node.path);
                if (index === -1) selectedItems.push(node.path);
                else selectedItems.splice(index, 1);
            } else if (node.type === 'folder') {
                if (actionType === 'code') {
                    const allFiles = getAllFiles(node);
                    const allSelected = allFiles.every(f => selectedItems.includes(f.path));
                    if (allSelected) {
                        allFiles.forEach(f => {
                            const idx = selectedItems.indexOf(f.path);
                            if (idx !== -1) selectedItems.splice(idx, 1);
                        });
                    } else {
                        allFiles.forEach(f => {
                            if (!selectedItems.includes(f.path)) selectedItems.push(f.path);
                        });
                    }
                } else {
                    const idx = selectedItems.indexOf(node.path);
                    if (idx === -1) selectedItems.push(node.path);
                    else selectedItems.splice(idx, 1);
                }

                // Toggle expand/collapse for folders with children
                if (node.children?.length) {
                    const newExpandedState = !isExpanded;
                    expandedFolders.set(node.path, newExpandedState);
                    
                    // Find the children container and toggle its display
                    const childrenContainer = nodeWrapper.querySelector('.children');
                    if (childrenContainer) {
                        childrenContainer.style.display = newExpandedState ? 'flex' : 'none';
                    }
                    
                    // Update folder icon
                    if (newExpandedState) {
                        el.classList.add('folder-open');
                    } else {
                        el.classList.remove('folder-open');
                    }
                }
            }

            // Update selection highlights without re-rendering
            updateSelectionHighlights();

            if (onToggle) onToggle(node);
        });

        return nodeWrapper;
    }

    // Helper to update selection highlights without full re-render
    function updateSelectionHighlights() {
        const allNodes = container.querySelectorAll('.tree-node');
        allNodes.forEach(nodeEl => {
            const wrapper = nodeEl.parentElement;
            const nodePath = wrapper.dataset.nodePath;
            
            if (!nodePath) return;
            
            const isSelected = selectedItems.includes(nodePath);
            
            // Remove all selection classes
            nodeEl.classList.remove('selected', 'folder-selected', 'file-selected');
            
            // Re-apply based on current state
            if (nodeEl.classList.contains('folder')) {
                if (actionType === 'code' && isSelected) {
                    nodeEl.classList.add('folder-selected');
                } else if (isSelected) {
                    nodeEl.classList.add('selected');
                }
            } else if (nodeEl.classList.contains('file') && isSelected) {
                nodeEl.classList.add('file-selected');
            }
        });
        
        updateGenerateState();
    }

    function updateGenerateState() {
        const generateBtn = document.getElementById('generateBtn');
        if (generateBtn) {
            generateBtn.disabled = selectedItems.length === 0;
        }
    }

    // Create tree container with root level
    const treeRoot = document.createElement('div');
    treeRoot.classList.add('tree-root');

    treeData.forEach(node => {
        const n = createNode(node, 0);
        if (n) treeRoot.appendChild(n);
    });

    container.appendChild(treeRoot);
}

