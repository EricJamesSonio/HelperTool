------------------------------
FILE: config\config.js

const fs = require('fs');
const path = require('path');
const { app } = require('electron');

const CONFIG_PATH = path.join(__dirname, 'helper-config.json');

function readConfig() {
    if (!fs.existsSync(CONFIG_PATH)) {
        const defaultConfig = {
            baseStoragePath: path.join(app.getPath('userData'), 'HelperToolStorage'),
            activeProject: null,
            projects: {},
            preferences: {
                docignoreFileName: ".docignore",
                showHiddenFiles: false,
                defaultStructureView: "tree",
                autoSelectLastProject: true
            }
        };
        fs.writeFileSync(CONFIG_PATH, JSON.stringify(defaultConfig, null, 2));
        return defaultConfig;
    }
    return JSON.parse(fs.readFileSync(CONFIG_PATH));
}

function writeConfig(config) {
    fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2));
}

function getActiveProject() {
    const config = readConfig();
    if (config.activeProject) {
        return config.projects[config.activeProject];
    }
    return null;
}

function getLastSelectedItems() {
    const project = getActiveProject();
    return project?.lastSelectedItems || [];
}

function setLastSelectedItems(items) {
    const cfg = readConfig();
    if (cfg.activeProject && cfg.projects[cfg.activeProject]) {
        cfg.projects[cfg.activeProject].lastSelectedItems = items;
        writeConfig(cfg);
    }
}

function ensureStorageFolder(storagePath) {
    if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
    ['Codes', 'Structures'].forEach(sub => {
        const subPath = path.join(storagePath, sub);
        if (!fs.existsSync(subPath)) fs.mkdirSync(subPath);
    });
    return storagePath;
}

module.exports = { 
    readConfig, 
    writeConfig, 
    getActiveProject, 
    getLastSelectedItems,
    setLastSelectedItems,
    ensureStorageFolder
};


------------------------------
FILE: config\helper-config.json

{
  "baseStoragePath": "C:/Users/Windows10/Desktop/HelperToolStorage",
  "activeProject": "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduToolV2",
  "projects": {
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduTool\\client\\src": {
      "storageName": "src",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\src",
      "lastUsed": "2026-01-05T10:06:31.639Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\backend": {
      "storageName": "backend",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\backend",
      "lastUsed": "2026-01-05T10:06:54.589Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Parallel\\Guitar-store": {
      "storageName": "Guitar-store",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Guitar-store",
      "lastUsed": "2026-01-05T10:34:07.131Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown": {
      "storageName": "Gown",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Gown",
      "lastUsed": "2026-01-06T02:17:56.102Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\Jollibee": {
      "storageName": "Jollibee",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Jollibee",
      "lastUsed": "2026-01-05T14:42:20.003Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Excalidraw": {
      "storageName": "Excalidraw",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Excalidraw",
      "lastUsed": "2026-01-06T02:17:34.325Z",
      "lastSelectedItems": [
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Excalidraw\\Labdoc.excalidraw"
      ]
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EventDrivenArchitecture": {
      "storageName": "EventDrivenArchitecture",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\EventDrivenArchitecture",
      "lastUsed": "2026-01-06T03:10:54.347Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\STUDYLY": {
      "storageName": "STUDYLY",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\STUDYLY",
      "lastUsed": "2026-01-06T03:21:11.358Z",
      "lastSelectedItems": [
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\STUDYLY\\Presentation"
      ]
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduToolV2": {
      "storageName": "EduToolV2",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\EduToolV2",
      "lastUsed": "2026-01-06T03:24:49.189Z",
      "lastSelectedItems": []
    }
  },
  "preferences": {
    "docignoreFileName": ".docignore",
    "showHiddenFiles": false,
    "defaultStructureView": "tree",
    "autoSelectLastProject": true
  }
}

------------------------------
FILE: main.js

const { app, BrowserWindow, Tray, Menu, ipcMain, shell, dialog } = require('electron');
const path = require('path');
const fs = require('fs');
const config = require('./config/config.js');

// Utils
const fileOps = require('./utils/fileOps.js');
const docignoreUtils = require('./utils/docignore.js');
const codeOps = require('./utils/codeOps.js');

let mainWindow;
let tray;

// ----------------------------
// Create Main Window
// ----------------------------
function createWindow() {
    console.log('[Main] Creating main window...');
    mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        show: true,
        webPreferences: {
            preload: path.join(__dirname, 'preload.js')
        }
    });

    mainWindow.loadFile(path.join(__dirname, 'renderer', 'index.html'));

    mainWindow.on('close', (e) => {
        e.preventDefault();
        mainWindow.hide();
        console.log('[Main] Main window hidden instead of close');
    });
}

// ----------------------------
// App Ready
// ----------------------------
app.whenReady().then(() => {
    console.log('[Main] App is ready');
    createTray();
    createWindow();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });
});

// ----------------------------
// Tray
// ----------------------------
function createTray() {
    console.log('[Tray] Creating tray icon...');
    tray = new Tray(path.join(__dirname, 'assets', 'tray-icon.png'));

    const contextMenu = Menu.buildFromTemplate([
        { label: 'Open Helper', click: () => mainWindow.show() },
        { label: 'Open Storage Folder', click: () => openStorage() },
        { type: 'separator' },
        { label: 'Select Previous Repo', submenu: getPreviousReposMenu() },
        { type: 'separator' },
        { label: 'Exit', click: () => app.quit() }
    ]);

    tray.setToolTip('Helper Tool');
    tray.setContextMenu(contextMenu);
    console.log('[Tray] Tray menu created');
}

// main.js additions
ipcMain.handle('open-global-docignore', async () => {
    try {
        const globalDocignorePath = path.join(app.getPath('userData'), 'global-docignore.json');

        // Create file if it doesn't exist
        if (!fs.existsSync(globalDocignorePath)) {
            fs.writeFileSync(globalDocignorePath, JSON.stringify([], null, 2), 'utf-8');
            console.log('[Main] Created new global-docignore.json at', globalDocignorePath);
        } else {
            console.log('[Main] global-docignore.json exists at', globalDocignorePath);
        }

        // Open with default editor
        await shell.openPath(globalDocignorePath);
        console.log('[Main] global-docignore.json opened');
        return true;
    } catch (err) {
        console.error('[Main] Failed to open global-docignore.json:', err);
        return false;
    }
});

ipcMain.handle('open-storage', async () => {
    try {
        openStorage(); // just reuse the existing function
        return true;
    } catch (err) {
        console.error('[IPC] open-storage failed:', err);
        return false;
    }
});


// ----------------------------
// Previous Repos Menu
// ----------------------------
function getPreviousReposMenu() {
    const cfg = config.readConfig();
    const submenu = [];

    for (const repoPath in cfg.projects) {
        submenu.push({
            label: path.basename(repoPath),
            click: () => {
                console.log('[Tray] Setting active project:', repoPath);
                cfg.activeProject = repoPath;
                config.writeConfig(cfg);
            }
        });
    }

    if (submenu.length === 0) {
        submenu.push({ label: 'No previous repos', enabled: false });
        console.log('[Tray] No previous repos found');
    }

    return submenu;
}

// ----------------------------
// Open Storage Folder
// ----------------------------
function openStorage() {
    try {
        const activeProject = config.getActiveProject();
        if (activeProject) {
            const storagePath = activeProject.storagePath;
            console.log('[Storage] Opening storage folder:', storagePath);
            if (fs.existsSync(storagePath)) {
                shell.openPath(storagePath);
            } else {
                console.warn('[Storage] Storage folder does not exist:', storagePath);
                dialog.showErrorBox('Storage Not Found', 'Storage folder does not exist.');
            }
        } else {
            console.warn('[Storage] No active project');
            dialog.showErrorBox('No Active Project', 'Select a project first.');
        }
    } catch (err) {
        console.error('[Error] openStorage failed:', err);
    }
}

// ----------------------------
// IPC Handlers
// ----------------------------

// Select repo
ipcMain.handle('select-repo', async () => {
    try {
        console.log('[IPC] select-repo called');
        const result = await dialog.showOpenDialog({ properties: ['openDirectory'] });

        if (result.canceled || !result.filePaths.length) {
            console.log('[IPC] Repo selection cancelled');
            return null;
        }

        const repoPath = result.filePaths[0];
        console.log('[IPC] Repo selected:', repoPath);

        const cfg = config.readConfig();
        const storageName = path.basename(repoPath).replace(/[^a-zA-Z0-9-_]/g, '_');
        const userDataPath = app.getPath('userData');
        const storagePath = path.join(userDataPath, storageName);

        // Create storage folders
        if (!fs.existsSync(userDataPath)) fs.mkdirSync(userDataPath, { recursive: true });
        if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
        ['Codes', 'Structures'].forEach(sub => {
            const subPath = path.join(storagePath, sub);
            if (!fs.existsSync(subPath)) fs.mkdirSync(subPath, { recursive: true });
        });
        console.log('[IPC] Storage folders ensured at:', storagePath);

        // Update config
        cfg.projects[repoPath] = {
            storageName,
            storagePath,
            lastUsed: new Date().toISOString()
        };
        cfg.activeProject = repoPath;
        config.writeConfig(cfg);
        console.log('[IPC] Config updated for repo:', repoPath);

        return repoPath;
    } catch (err) {
        console.error('[IPC] select-repo error:', err);
        dialog.showErrorBox('Select Repo Error', err.message);
        return null;
    }
});

ipcMain.handle('getFolderTree', async (event, repoPath) => {
    try {
        if (!repoPath) return [];

        // No need to load repo-specific docignore anymore
        const ignoreRules = []; // optional: load repo-specific rules if needed
        const tree = fileOps.getFolderTree(repoPath, ignoreRules);
        return tree;
    } catch (err) {
        console.error('[IPC] getFolderTree error:', err);
        return [];
    }
});
ipcMain.handle('get-user-data-path', () => app.getPath('userData'));


ipcMain.handle('generate', async (event, actionType, repoPath, items, filePath) => {
    try {
        console.log('[IPC] generate called:', { actionType, repoPath, itemsLength: items?.length, filePath });
        if (!repoPath || !items?.length || !filePath) throw new Error('Invalid arguments');

        const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);

        // Ensure the directory of the output file exists
        const outputDir = path.dirname(filePath);
        if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

        if (actionType === 'structure') {
            console.log('[IPC] Generating structure...');
            await fileOps.generateStructure(items, filePath, ignoreRules, (percent) => {
                mainWindow.webContents.send('progress-update', percent);
                //console.log(`[Progress] ${percent}%`);
            });
        } else if (actionType === 'code') {
            console.log('[IPC] Generating code...');
            await codeOps.generateCode(items, filePath, (percent) => {
                mainWindow.webContents.send('progress-update', percent);
                console.log(`[Progress] ${percent}%`);
            }, repoPath, ignoreRules);
        }

        console.log(`[IPC] Generation complete. Output at: ${filePath}`);
        return true;
    } catch (err) {
        console.error('[IPC] generate error:', err);
        dialog.showErrorBox('Generate Error', err.message);
        return false;
    }
});

// ----------------------------
// Open .docignore file
// ----------------------------
ipcMain.handle('open-docignore', async (event, repoPath) => {
    try {
        if (!repoPath) return false;
        const docignoreFile = path.join(repoPath, '.docignore');

        // If file doesn't exist, create empty
        if (!fs.existsSync(docignoreFile)) {
            fs.writeFileSync(docignoreFile, '# Add patterns to ignore files/folders\n', 'utf-8');
        }

        // Open with default editor
        shell.openPath(docignoreFile);
        console.log('[Main] .docignore opened:', docignoreFile);
        return true;
    } catch (err) {
        console.error('[IPC] open-docignore error:', err);
        return false;
    }
});


// Get .docignore rules
ipcMain.handle('get-docignore', async (event, repoPath) => {
    try {
        console.log('[IPC] get-docignore called for:', repoPath);
        if (!repoPath) return [];
        return await docignoreUtils.getIgnoreRules(repoPath);
    } catch (err) {
        console.error('[IPC] get-docignore error:', err);
        return [];
    }
});

// Get active project
ipcMain.handle('get-active-project', () => {
    try {
        console.log('[IPC] get-active-project called');
        const activeProjectPath = config.readConfig().activeProject;
        if (!activeProjectPath) return null;
        const projectData = config.readConfig().projects[activeProjectPath];
        console.log('[IPC] Active project data:', projectData);
        return { repoPath: activeProjectPath, ...projectData };
    } catch (err) {
        console.error('[IPC] get-active-project error:', err);
        return null;
    }
});

// Get last selected items
ipcMain.handle('get-last-selected', () => {
    try {
        const items = config.getLastSelectedItems();
        console.log('[IPC] get-last-selected:', items);
        return items;
    } catch (err) {
        console.error('[IPC] get-last-selected error:', err);
        return [];
    }
});

// Set last selected items
ipcMain.handle('set-last-selected', (event, items) => {
    try {
        console.log('[IPC] set-last-selected:', items);
        config.setLastSelectedItems(items);
    } catch (err) {
        console.error('[IPC] set-last-selected error:', err);
    }
});

ipcMain.handle('save-file-dialog', async (event, actionType) => {
    const activeProject = config.getActiveProject();
    if (!activeProject) return { filePath: null };

    const defaultFolder = path.join(
        activeProject.storagePath,
        actionType === 'code' ? 'Codes' : 'Structures'
    );

    const result = await dialog.showSaveDialog({
        title: 'Enter output file name',
        defaultPath: path.join(defaultFolder, 'output.txt'),
        buttonLabel: 'Save'
    });

    return { filePath: result.canceled ? null : result.filePath };
});


------------------------------
FILE: preload.js

// preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
    // ------------------------
    // Repo selection
    // ------------------------
    selectRepo: () => ipcRenderer.invoke('select-repo'),

    // ------------------------
    // Folder tree
    // ------------------------
    getFolderTree: (repoPath) => ipcRenderer.invoke('getFolderTree', repoPath),

    // ------------------------
    // Generate structure/code
    // ------------------------
    generate: (actionType, repoPath, items, filePath) => {
        return ipcRenderer.invoke('generate', actionType, repoPath, items, filePath);
    },

    // ------------------------
    // Open storage folder
    // ------------------------
    openStorage: () => ipcRenderer.invoke('open-storage'),
    openDocignore: (repoPath) => ipcRenderer.invoke('open-docignore', repoPath),
    getUserDataPath: () => ipcRenderer.invoke('get-user-data-path'),
    openGlobalDocignore: () => ipcRenderer.invoke('open-global-docignore'),

    // ------------------------
    // Progress updates
    // ------------------------
    onProgressUpdate: (callback) => {
        ipcRenderer.removeAllListeners('progress-update'); // avoid duplicate callbacks
        ipcRenderer.on('progress-update', (event, percent) => {
            const validPercent = Math.min(Math.max(Math.round(percent), 0), 100);
            callback(validPercent);
        });
    },

    // ------------------------
    // .docignore
    // ------------------------
    getDocignore: (repoPath) => ipcRenderer.invoke('get-docignore', repoPath),

    // ------------------------
    // Last selected items
    // ------------------------
    getLastSelected: () => ipcRenderer.invoke('get-last-selected'),
    setLastSelected: (items) => ipcRenderer.invoke('set-last-selected', items),

    // ------------------------
    // Active project
    // ------------------------
    getActiveProject: () => ipcRenderer.invoke('get-active-project'),

    // ------------------------
    // Save file dialog (new)
    // ------------------------
    saveFileDialog: (actionType) => ipcRenderer.invoke('save-file-dialog', actionType)
});


------------------------------
FILE: renderer\app.js

import { renderTree } from '../utils/treeView.js';

const selectRepoBtn = document.getElementById('selectRepoBtn');
const activeRepoName = document.getElementById('activeRepoName');
const treeContainer = document.getElementById('treeContainer');
const structureBtn = document.getElementById('structureBtn');
const codeBtn = document.getElementById('codeBtn');
const generateBtn = document.getElementById('generateBtn');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const openStorageBtn = document.getElementById('openStorageBtn'); // new

let selectedRepoPath = null;
let selectedItems = [];
let actionType = 'code';
let cachedTree = null;

// UI setup
treeContainer.style.overflowY = 'auto';
treeContainer.style.maxHeight = '80vh';
generateBtn.disabled = true;

// ----------------------------
// Progress listener
// ----------------------------
window.electronAPI.onProgressUpdate((percent) => {
    progressBar.value = percent;
    progressText.textContent = `${percent}%`;
    //console.log(`[Progress] ${percent}%`);
});

// ----------------------------
// Helpers
// ----------------------------
function updateActiveRepo(name) {
    activeRepoName.textContent = name || 'No repo selected';
    console.log(`[UI] Active repo set to: ${name}`);
}

openStorageBtn.addEventListener('click', async () => {
    try {
        console.log('[UI] Open Storage clicked');
        await window.electronAPI.openStorage();
    } catch (err) {
        console.error('[UI] Failed to open storage:', err);
        alert('Failed to open storage. Check console for details.');
    }
});

function updateGenerateState() {
    generateBtn.disabled = selectedItems.length === 0;
    console.log(`[UI] Generate button ${generateBtn.disabled ? 'disabled' : 'enabled'}`);
}

// ----------------------------
// Load last active repo
// ----------------------------
async function loadLastActiveRepo() {
    try {
        console.log('[Init] Loading last active project...');
        const project = await window.electronAPI.getActiveProject();
        console.log('[Init] Last active project data:', project);

        if (project?.repoPath) {
            await loadRepo(project.repoPath);
            selectedItems = project.lastSelectedItems || [];
            console.log('[Init] Loaded last selected items:', selectedItems);
        } else {
            console.log('[Init] No last active project found.');
        }
    } catch (err) {
        console.error('[Error] Failed to load last active project:', err);
    }
}

// ----------------------------
// Select repo button
// ----------------------------
selectRepoBtn.addEventListener('click', async () => {
    try {
        console.log('[Action] Select repo clicked');
        const repoPath = await window.electronAPI.selectRepo();
        if (repoPath) {
            console.log('[Action] Repo selected:', repoPath);
            await loadRepo(repoPath);
        } else {
            console.log('[Action] Repo selection cancelled or invalid');
        }
    } catch (err) {
        console.error('[Error] Selecting repo failed:', err);
        alert('Error selecting repo. Check console for details.');
    }
});

// ----------------------------
// Load a repo
// ----------------------------
async function loadRepo(repoPath) {
    try {
        console.log('[LoadRepo] Loading repo:', repoPath);

        selectedRepoPath = repoPath;
        selectedItems = [];
        await window.electronAPI.setLastSelected([]);
        console.log('[LoadRepo] Cleared previous selections');

        const repoName = repoPath.split(/[/\\]/).pop();
        updateActiveRepo(repoName);

        cachedTree = await window.electronAPI.getFolderTree(repoPath);
        console.log('[LoadRepo] Folder tree loaded:', cachedTree);

        updateGenerateState();
        displayTree();
    } catch (err) {
        console.error('[Error] Loading repo failed:', err);
        alert('Failed to load repo. See console.');
    }
}

// ----------------------------
// Display tree
// ----------------------------
function displayTree() {
    try {
        if (!cachedTree) {
            console.log('[DisplayTree] No tree data to display');
            treeContainer.textContent = 'No data available';
            return;
        }
        console.log('[DisplayTree] Rendering tree...');
        renderTree(cachedTree, treeContainer, selectedItems, actionType, toggleSelect);
    } catch (err) {
        console.error('[Error] Displaying tree failed:', err);
    }
}

// ----------------------------
// Selection logic
// ----------------------------
function toggleSelect(node) {
    try {
        if (!selectedRepoPath || !cachedTree) return;

        const isSelected = selectedItems.includes(node.path);

        if (isSelected) {
            selectedItems = selectedItems.filter(p => p !== node.path);
            console.log('[Select] Deselected:', node.path);
        } else {
            selectedItems.push(node.path);
            console.log('[Select] Selected:', node.path);
        }

        window.electronAPI.setLastSelected(selectedItems);
        updateGenerateState();

        if (node.type === 'folder' && actionType === 'code') displayTree();
    } catch (err) {
        console.error('[Error] toggleSelect failed:', err);
    }
}

// ----------------------------
// Mode switching
// ----------------------------
function resetSelection() {
    try {
        selectedItems = [];
        window.electronAPI.setLastSelected([]);
        updateGenerateState();
        console.log('[UI] Selection reset');
    } catch (err) {
        console.error('[Error] resetSelection failed:', err);
    }
}

structureBtn.addEventListener('click', () => {
    try {
        console.log('[Action] Switch to structure mode');
        actionType = 'structure';
        resetSelection();
        displayTree();
    } catch (err) {
        console.error('[Error] Switching to structure mode failed:', err);
    }
});

const editDocignoreBtn = document.getElementById('editDocignoreBtn');

// ----------------------------
// Edit .docignore button
// ----------------------------
// ----------------------------
// Edit .docignore button (updated)
// ----------------------------
editDocignoreBtn.addEventListener('click', async () => {
    try {
        console.log('[UI] Edit Global .docignore clicked');

        const result = await window.electronAPI.openGlobalDocignore();

        if (result) {
            console.log('[UI] Global .docignore opened successfully');
        } else {
            console.warn('[UI] Failed to open global .docignore');
            alert('Failed to open global ignore file. Check console.');
        }
    } catch (err) {
        console.error('[UI] Error opening global .docignore:', err);
        alert('Error opening global ignore file. Check console.');
    }
});




codeBtn.addEventListener('click', () => {
    try {
        console.log('[Action] Switch to code mode');
        actionType = 'code';
        resetSelection();
        displayTree();
    } catch (err) {
        console.error('[Error] Switching to code mode failed:', err);
    }
});

// ----------------------------
// Generate
// ----------------------------
generateBtn.addEventListener('click', async () => {
    try {
        if (!selectedRepoPath || !selectedItems.length) {
            console.log('[Generate] No repo or items selected');
            return alert('Select repo and items first!');
        }

        // Step 1: Show save file dialog
        const { filePath } = await window.electronAPI.saveFileDialog(actionType);
        if (!filePath) {
            console.log('[Generate] User cancelled file save dialog');
            return;
        }

        // Step 2: Reset progress
        progressBar.value = 0;
        progressText.textContent = '0%';

        // Step 3: Generate
        console.log(`[Generate] Generating ${actionType} for ${selectedItems.length} items to "${filePath}"`);
        const result = await window.electronAPI.generate(actionType, selectedRepoPath, selectedItems, filePath);

        console.log('[Generate] Generation result:', result);

        alert('Done!');
        resetSelection();
        displayTree();
    } catch (err) {
        console.error('[Error] Generation failed:', err);
        alert('Generation failed. Check console for details.');
    }
});


// ----------------------------
// Init
// ----------------------------
window.addEventListener('DOMContentLoaded', () => {
    console.log('[Init] DOM loaded');
    loadLastActiveRepo();
});


------------------------------
FILE: renderer\index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Helper Tool</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="app">
    <h1>Helper Tool</h1>

    <!-- Repo selection -->
    <div class="section repo-selection">
      <button id="selectRepoBtn">Select Repo</button>
      <span id="activeRepoName">No repo selected</span>
    </div>

    <!-- Tree view -->
    <div class="section tree-view">
      <h2>Project Tree</h2>
      <div id="treeContainer">Select a repo to view files</div>
    </div>

<!-- Action buttons -->
<div class="section actions">
  <button id="structureBtn" class="action-btn">Structure</button>
  <button id="codeBtn" class="action-btn">Code</button>
  <button id="generateBtn" class="action-btn">Done / Generate</button>
  <button id="editDocignoreBtn" class="action-btn">Edit .docignore</button>
  <button id="openStorageBtn" class="action-btn">Open Storage</button> <!-- NEW -->
</div>


    <!-- Progress -->
    <div class="section progress-section">
      <progress id="progressBar" value="0" max="100"></progress>
      <span id="progressText">0%</span>
    </div>
  </div>

  <!-- App logic -->
  <script type="module" src="app.js"></script>
</body>
</html>


------------------------------
FILE: renderer\style.css

/* -----------------------------
   Reset & Base Styles
----------------------------- */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body {
  background-color: #f5f6fa;
  color: #333;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  padding: 10px;
}

#app {
  background-color: #fff;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,0.1);
  width: 95%;
  height: 90vh;
  display: flex;
  flex-direction: column;
}

/* -----------------------------
   Titles & Sections
----------------------------- */
#app h1 {
  text-align: center;
  margin-bottom: 20px;
  font-size: 2rem;
  color: #2f3640;
}

.section {
  margin-bottom: 20px;
}

.section h2 {
  margin-bottom: 10px;
  font-size: 1.2rem;
  color: #2d3436;
}

#activeRepoName {
  margin-left: 10px;
  font-weight: 500;
  color: #636e72;
}

/* -----------------------------
   Buttons
----------------------------- */
button {
  padding: 10px 18px;
  border: none;
  border-radius: 6px;
  background-color: #0984e3;
  color: #fff;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s ease, transform 0.1s ease;
  margin-right: 10px;
}

button:hover {
  background-color: #74b9ff;
  transform: translateY(-2px);
}

button:active {
  transform: translateY(0);
}

button:disabled {
  background-color: #b2bec3;
  cursor: not-allowed;
}

.action-btn {
  margin-right: 10px;
}

/* -----------------------------
   Tree Container
----------------------------- */
#treeContainer {
  flex: 1;
  padding: 10px;
  background-color: #f9f9f9;
  border-radius: 8px;
  border: 1px solid #ccc;
  overflow: auto;
  display: flex;
  flex-direction: column;
  font-family: monospace;
}

/* -----------------------------
   Tree Node Base
----------------------------- */
.tree-node {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  margin: 2px 0;
  cursor: pointer;
  transition: background-color 0.2s ease;
  user-select: none;
  padding: 4px 6px;
}

/* Folder / File types */
.tree-node.folder {
  font-weight: 500;
  color: #0984e3;
}
.tree-node.file {
  font-size: 0.9em;
  color: #636e72;
}

/* Folder icons */
.tree-node.folder::before {
  content: "ðŸ“ ";
}
.tree-node.folder.folder-open::before {
  content: "ðŸ“‚ ";
}

/* File icon */
.tree-node.file::before {
  content: "ðŸ“„ ";
}

/* Hover */
.tree-node:hover {
  background-color: #dfe6e9;
}

/* Selected Highlights */
.tree-node.folder.selected {
  background-color: #74b9ff;
  color: #fff;
  font-weight: bold;
}
.tree-node.folder.folder-selected {
  background-color: #d0f0d0;
  color: #00b894;
  font-weight: bold;
}
.tree-node.file.file-selected {
  background-color: #ffeaa7;
  color: #2d3436;
  font-weight: bold;
}

/* -----------------------------
   Children Layout (Horizontal)
----------------------------- */
.children {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-left: 20px;
}

.children .tree-node.file {
  flex: 1 1 100px; /* Each file takes 1 space, min 100px */
  padding: 6px;
  border-radius: 6px;
  text-align: center;
  background-color: #fafafa;
  transition: all 0.2s ease;
}

.children .tree-node.folder {
  flex: 1 1 auto;
  padding: 6px;
  margin-bottom: 6px;
}

/* Collapsed */
.children.collapsed {
  display: none;
}

/* -----------------------------
   Progress Bar
----------------------------- */
progress {
  width: 100%;
  height: 20px;
  border-radius: 10px;
  overflow: hidden;
  margin-top: 5px;
}
progress::-webkit-progress-bar { background: #dfe6e9; }
progress::-webkit-progress-value { background: #00b894; }
progress::-moz-progress-bar { background: #00b894; }

#progressText {
  display: inline-block;
  margin-left: 10px;
  font-weight: 500;
  color: #2d3436;
}

/* -----------------------------
   Responsive
----------------------------- */
@media (max-width: 768px) {
  #treeContainer {
    flex-direction: column;
  }
  .children {
    flex-direction: column;
  }
  button {
    width: 100%;
    margin-bottom: 10px;
  }
  .action-btn {
    margin-right: 0;
  }
}


------------------------------
FILE: utils\codeOps.js

// file: codeOps.js
const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect files from folder respecting ignore rules
 * @param {string} folderPath
 * @param {string[]} ignoreRules
 * @param {string} repoRoot
 */
function getAllFiles(folderPath, ignoreRules = [], repoRoot) {
    let files = [];
    if (!fs.existsSync(folderPath)) return files;

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        // Skip ignored files/folders
        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (item.isDirectory()) {
            files = files.concat(getAllFiles(fullPath, ignoreRules, repoRoot));
        } else if (item.isFile()) {
            files.push(fullPath);
        }
    }
    return files;
}

/**
 * Find repo root starting from a folder (optional fallback)
 * @param {string} startPath
 */
function findRepoRoot(startPath) {
    let dir = path.resolve(startPath);
    while (dir && dir !== path.parse(dir).root) {
        if (fs.existsSync(path.join(dir, '.docignore')) || fs.existsSync(path.join(dir, 'package.json'))) {
            return dir;
        }
        dir = path.dirname(dir);
    }
    return startPath; // fallback to the folder itself
}

/**
 * Generate combined code output from selected items
 * @param {string[]} selectedItems - user-selected files/folders
 * @param {string} outputFile - output file path
 * @param {function(number):void} onProgress - optional progress callback
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}) {
    if (!selectedItems.length) return;

    // Use the folder the user selected as repo root
    const repoRoot = path.resolve(selectedItems[0]);

    // Load ignore rules from the target repo only
    const ignoreRules = await getIgnoreRules(repoRoot);

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) {
            allFiles = allFiles.concat(getAllFiles(item, ignoreRules, repoRoot));
        } else if (stat.isFile() && !isIgnored(item, repoRoot, ignoreRules)) {
            allFiles.push(item);
        }
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        writeStream.write(`\n// ===== File: ${path.relative(repoRoot, filePath)} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }
    writeStream.close();
}

/**
 * Get folder tree structure for tree view respecting ignore rules
 * @param {string} dir
 * @param {string[]} ignoreRules
 * @param {string} repoRoot
 */
function getFolderTree(dir, ignoreRules = [], repoRoot) {
    if (!repoRoot) repoRoot = path.resolve(dir);

    if (isIgnored(dir, repoRoot, ignoreRules)) return [];

    let entries = [];
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
        return [];
    }

    return entries
        .filter(entry => {
            const fullPath = path.join(dir, entry.name);
            return !isIgnored(fullPath, repoRoot, ignoreRules);
        })
        .map(entry => {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                return {
                    name: entry.name,
                    path: fullPath,
                    type: 'folder',
                    children: getFolderTree(fullPath, ignoreRules, repoRoot),
                };
            }
            return { name: entry.name, path: fullPath, type: 'file' };
        });
}

module.exports = { generateCode, getAllFiles, findRepoRoot, getFolderTree };


------------------------------
FILE: utils\docignore.js

const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch');
const { app } = require('electron');

const globalIgnorePath = path.join(app.getPath('userData'), 'global-docignore.json');

// ----------------------------
// Cached Global Rules
// ----------------------------
let cachedGlobalRules = null;

function loadGlobalIgnoreRules() {
    if (cachedGlobalRules) return cachedGlobalRules;

    if (!fs.existsSync(globalIgnorePath)) {
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }

    try {
        const data = fs.readFileSync(globalIgnorePath, 'utf-8');
        cachedGlobalRules = JSON.parse(data);
        console.log('[Docignore] Global ignore rules loaded:', cachedGlobalRules);
        return cachedGlobalRules;
    } catch (err) {
        console.error('[Docignore] Failed to read global ignore:', err);
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }
}

// ----------------------------
// Repo-specific + combined rules
// ----------------------------
async function getIgnoreRules(repoPath) {
    try {
        let repoRules = [];
        const repoIgnoreFile = path.join(repoPath, '.docignore');

        if (fs.existsSync(repoIgnoreFile)) {
            const data = fs.readFileSync(repoIgnoreFile, 'utf-8');
            try {
                repoRules = JSON.parse(data);
            } catch (err) {
                console.warn('[Docignore] Failed to parse repo .docignore, skipping:', err.message);
            }
        }

        const combinedRules = [...loadGlobalIgnoreRules(), ...repoRules];
        console.log('[Docignore] Combined ignore rules for', repoPath, combinedRules);
        return combinedRules;
    } catch (err) {
        console.error('[Docignore] getIgnoreRules error:', err);
        return [];
    }
}

// ----------------------------
// Check if path is ignored
// ----------------------------
function isIgnored(fullPath, repoPath, rules = []) {
    if (!repoPath) return false;

    let relPath = path.relative(repoPath, fullPath);

    // Normalize for Windows + micromatch
    relPath = relPath.replace(/\\/g, '/');

    // Ignore anything outside the repo
    if (relPath.startsWith('..')) return false;
    console.log('[Docignore] Checking:', relPath, 'Rules:', rules);

    const ignored = micromatch.isMatch(relPath, rules, { dot: true });

    isIgnored.loggedFiles = isIgnored.loggedFiles || new Set();
    if (ignored && !isIgnored.loggedFiles.has(relPath)) {
        console.log('[Docignore] Ignored:', relPath);
        isIgnored.loggedFiles.add(relPath);
    }

    return ignored;
}


module.exports = { isIgnored, loadGlobalIgnoreRules, getIgnoreRules };


------------------------------
FILE: utils\fileOps.js

// file: fileOps.js
const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Get folder tree structure for tree view
 * @param {string} dir - starting directory
 * @param {string[]} ignoreRules - optional ignore rules
 * @param {string} repoRoot - repo root path
 */
async function getFolderTree(dir, ignoreRules = [], repoRoot) {
    if (!repoRoot) repoRoot = path.resolve(dir);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    if (isIgnored(dir, repoRoot, ignoreRules)) return [];

    let entries = [];
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch (err) {
        return [];
    }

    const tree = [];
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (entry.isDirectory()) {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'folder',
                children: await getFolderTree(fullPath, ignoreRules, repoRoot),
            });
        } else {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'file',
            });
        }
    }

    return tree;
}

/**
 * Generate folder structure output (text) respecting repo ignore rules
 * @param {string[]} selectedPaths - folders/files selected by user
 * @param {string} outputFile - path to write structure text
 * @param {function(number):void} progressCallback - optional progress update
 */
async function generateStructure(selectedPaths, outputFile, progressCallback = () => {}) {
    if (!selectedPaths || !selectedPaths.length) return;

    // Use the first selected path as repo root
    const repoRoot = path.resolve(selectedPaths[0]);

    // Load ignore rules for this repo
    const ignoreRules = await getIgnoreRules(repoRoot);

    const outputLines = [];
    const allItems = [];

function collect(currentPath, depth = 0) {
    if (isIgnored(currentPath, repoRoot, ignoreRules)) return;

    let stat;
    try { stat = fs.statSync(currentPath); } catch { return; }

    if (stat.isFile() || (stat.isDirectory() && fs.readdirSync(currentPath).length > 0)) {
        allItems.push({ path: currentPath, depth });
    }

    if (stat.isDirectory()) {
        const children = fs.readdirSync(currentPath);
        for (const child of children) {
            collect(path.join(currentPath, child), depth + 1);
        }
    }
}


    selectedPaths.forEach(p => collect(p, 0));

    // Build output lines for folder structure
    allItems.forEach((item, idx) => {
        const stat = fs.statSync(item.path);
        const prefix = '  '.repeat(item.depth);
        outputLines.push(`${prefix}${path.basename(item.path)}${stat.isDirectory() ? '/' : ''}`);

        progressCallback(Math.round(((idx + 1) / allItems.length) * 100));
    });

    fs.writeFileSync(outputFile, outputLines.join('\n'), 'utf-8');
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: utils\treeView.js

/**
 * Tree View Renderer
 * -----------------
 * - Shows folders always
 * - Files shown in code mode
 * - Click to select folders/files
 * - Folder selection in code mode = all files inside selected recursively
 * - Highlights selected items
 * - Displays children in horizontal rows (flex)
 */
export function renderTree(treeData, container, selectedItems, actionType, onToggle) {
    container.innerHTML = '';

    // Store expanded/collapsed folder state
    const expandedFolders = new WeakMap();

    // Recursively get all files under a folder (ignores folders with no files)
    function getAllFiles(node) {
        if (node.type === 'file') return [node];
        if (!node.children?.length) return [];
        return node.children.flatMap(getAllFiles);
    }

    // Count only visible files recursively
    function countFiles(node) {
        if (node.type === 'file') return 1;
        if (!node.children?.length) return 0;
        return node.children.reduce((acc, child) => acc + countFiles(child), 0);
    }

    function createNode(node, isRoot = false) {
        // Skip files in structure mode
        if (actionType === 'structure' && node.type === 'file') return null;

        const el = document.createElement('div');
        el.classList.add('tree-node');
        if (node.type === 'file') el.classList.add('file');
        else el.classList.add('folder');

        const isSelected = selectedItems.includes(node.path);

        // Highlight selection
        if (node.type === 'folder' && actionType === 'code' && isSelected) el.classList.add('folder-selected');
        else if (node.type === 'file' && isSelected) el.classList.add('file-selected');
        else if (node.type === 'folder' && isSelected) el.classList.add('selected');

        // Label
        let label = node.name;
        if (node.type === 'folder' && node.children?.length && actionType !== 'structure') {
            const fileCount = countFiles(node);
            if (fileCount > 0) label += ` (${fileCount} files)`;
        }
        if (node.type === 'folder' && actionType === 'code' && isSelected) label += ' [ALL FILES]';
        el.textContent = label;

        // Children container
        let childrenContainer;
        if (node.type === 'folder' && node.children?.length) {
            childrenContainer = document.createElement('div');
            childrenContainer.classList.add('children');
            childrenContainer.style.display = expandedFolders.get(node) ? 'flex' : 'none';
            childrenContainer.style.flexWrap = 'wrap';
            childrenContainer.style.gap = '8px';
            childrenContainer.style.marginLeft = '20px';

            node.children.forEach(child => {
                const childNode = createNode(child);
                if (childNode) childrenContainer.appendChild(childNode);
            });

            el.appendChild(childrenContainer);
        }

        // Click logic
        el.addEventListener('click', e => {
            e.stopPropagation();

            if (node.type === 'file') {
                const index = selectedItems.indexOf(node.path);
                if (index === -1) selectedItems.push(node.path);
                else selectedItems.splice(index, 1);
            } else if (node.type === 'folder') {
                if (actionType === 'code') {
                    const allFiles = getAllFiles(node);
                    const allSelected = allFiles.every(f => selectedItems.includes(f.path));
                    if (allSelected) {
                        allFiles.forEach(f => {
                            const idx = selectedItems.indexOf(f.path);
                            if (idx !== -1) selectedItems.splice(idx, 1);
                        });
                    } else {
                        allFiles.forEach(f => {
                            if (!selectedItems.includes(f.path)) selectedItems.push(f.path);
                        });
                    }
                } else {
                    const idx = selectedItems.indexOf(node.path);
                    if (idx === -1) selectedItems.push(node.path);
                    else selectedItems.splice(idx, 1);
                }
            }

            // Folder expand/collapse
            if (node.type === 'folder') {
                const isExpanded = expandedFolders.get(node) || false;
                expandedFolders.set(node, !isExpanded);
                if (childrenContainer) childrenContainer.style.display = !isExpanded ? 'flex' : 'none';
                el.classList.toggle('folder-open', !isExpanded);
            }

            // Re-render container without losing root
            container.innerHTML = '';
            treeData.forEach(n => {
                const nodeEl = createNode(n, true);
                if (nodeEl) container.appendChild(nodeEl);
            });

            if (onToggle) onToggle(node);
        });

        return el;
    }

    // Always render root nodes, ignore rules only apply to children
    treeData.forEach(node => {
        const n = createNode(node, true);
        if (n) container.appendChild(n);
    });
}


