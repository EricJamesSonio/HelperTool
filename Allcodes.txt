------------------------------
FILE: config\config.js

const fs = require('fs');
const path = require('path');
const { app } = require('electron');

const CONFIG_PATH = path.join(__dirname, 'helper-config.json');

function readConfig() {
    if (!fs.existsSync(CONFIG_PATH)) {
        const defaultConfig = {
            baseStoragePath: path.join(app.getPath('userData'), 'HelperToolStorage'),
            activeProject: null,
            projects: {},
            preferences: {
                docignoreFileName: ".docignore",
                showHiddenFiles: false,
                defaultStructureView: "tree",
                autoSelectLastProject: true
            }
        };
        fs.writeFileSync(CONFIG_PATH, JSON.stringify(defaultConfig, null, 2));
        return defaultConfig;
    }
    return JSON.parse(fs.readFileSync(CONFIG_PATH));
}

function writeConfig(config) {
    fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2));
}

function getActiveProject() {
    const config = readConfig();
    if (config.activeProject) {
        return config.projects[config.activeProject];
    }
    return null;
}

function getLastSelectedItems() {
    const project = getActiveProject();
    return project?.lastSelectedItems || [];
}

function setLastSelectedItems(items) {
    const cfg = readConfig();
    if (cfg.activeProject && cfg.projects[cfg.activeProject]) {
        cfg.projects[cfg.activeProject].lastSelectedItems = items;
        writeConfig(cfg);
    }
}

function ensureStorageFolder(storagePath) {
    if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
    ['Codes', 'Structures'].forEach(sub => {
        const subPath = path.join(storagePath, sub);
        if (!fs.existsSync(subPath)) fs.mkdirSync(subPath);
    });
    return storagePath;
}

module.exports = { 
    readConfig, 
    writeConfig, 
    getActiveProject, 
    getLastSelectedItems,
    setLastSelectedItems,
    ensureStorageFolder
};


------------------------------
FILE: config\helper-config.json

{
  "baseStoragePath": "C:/Users/Windows10/Desktop/HelperToolStorage",
  "activeProject": "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown",
  "projects": {
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduTool\\client\\src": {
      "storageName": "src",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\src",
      "lastUsed": "2026-01-05T10:06:31.639Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\backend": {
      "storageName": "backend",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\backend",
      "lastUsed": "2026-01-05T10:06:54.589Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Parallel\\Guitar-store": {
      "storageName": "Guitar-store",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Guitar-store",
      "lastUsed": "2026-01-05T10:34:07.131Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown": {
      "storageName": "Gown",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Gown",
      "lastUsed": "2026-01-05T11:02:54.764Z",
      "lastSelectedItems": [
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown\\database",
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown\\server\\database"
      ]
    }
  },
  "preferences": {
    "docignoreFileName": ".docignore",
    "showHiddenFiles": false,
    "defaultStructureView": "tree",
    "autoSelectLastProject": true
  }
}

------------------------------
FILE: main.js

const { app, BrowserWindow, Tray, Menu, ipcMain, shell, dialog } = require('electron');
const path = require('path');
const fs = require('fs');
const config = require('./config/config.js');

// Utils
const fileOps = require('./utils/fileOps.js');
const docignoreUtils = require('./utils/docignore.js');
const codeOps = require('./utils/codeOps.js');

let mainWindow;
let tray;

function createWindow() {
    mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        show: true,
        webPreferences: {
            preload: path.join(__dirname, 'preload.js')
        }
    });

    mainWindow.loadFile(path.join(__dirname, 'renderer', 'index.html'));
    mainWindow.on('close', (e) => {
        e.preventDefault();
        mainWindow.hide();
    });
}

app.whenReady().then(() => {
    createTray();
    createWindow();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });
});

function createTray() {
    tray = new Tray(path.join(__dirname, 'assets', 'tray-icon.png'));
    const contextMenu = Menu.buildFromTemplate([
        { label: 'Open Helper', click: () => mainWindow.show() },
        { label: 'Open Storage Folder', click: () => openStorage() },
        { type: 'separator' },
        { label: 'Select Previous Repo', submenu: getPreviousReposMenu() },
        { type: 'separator' },
        { label: 'Exit', click: () => app.quit() }
    ]);
    tray.setToolTip('Helper Tool');
    tray.setContextMenu(contextMenu);
}

function getPreviousReposMenu() {
    const cfg = config.readConfig();
    const submenu = [];

    for (const repoPath in cfg.projects) {
        submenu.push({
            label: path.basename(repoPath),
            click: () => {
                cfg.activeProject = repoPath;
                config.writeConfig(cfg);
            }
        });
    }

    if (submenu.length === 0) {
        submenu.push({ label: 'No previous repos', enabled: false });
    }

    return submenu;
}

function openStorage() {
    const activeProject = config.getActiveProject();
    if (activeProject) {
        const storagePath = activeProject.storagePath;
        if (fs.existsSync(storagePath)) {
            shell.openPath(storagePath);
        } else {
            dialog.showErrorBox('Storage Not Found', 'Storage folder does not exist.');
        }
    } else {
        dialog.showErrorBox('No Active Project', 'Select a project first.');
    }
}

/* ===========================
   IPC Handlers
=========================== */

// 1️⃣ Select repo (updated to use userData storage)
ipcMain.handle('select-repo', async () => {
    const result = await dialog.showOpenDialog({
        properties: ['openDirectory']
    });

    if (result.canceled || !result.filePaths.length) return null;
    const repoPath = result.filePaths[0];

    const cfg = config.readConfig();
    const storageName = path.basename(repoPath).replace(/[^a-zA-Z0-9-_]/g, '_');

    // Save inside Electron userData folder
    const userDataPath = app.getPath('userData');
    const storagePath = path.join(userDataPath, storageName);

    try {
        // Ensure base folder exists
        if (!fs.existsSync(userDataPath)) fs.mkdirSync(userDataPath, { recursive: true });
        // Ensure storage folder and subfolders exist
        if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
        ['Codes', 'Structures'].forEach(sub => {
            const subPath = path.join(storagePath, sub);
            if (!fs.existsSync(subPath)) fs.mkdirSync(subPath, { recursive: true });
        });
    } catch (err) {
        dialog.showErrorBox('Permission Error', `Cannot create storage folder:\n${storagePath}\n\n${err.message}`);
        return null;
    }

    // Add or update project in config
    cfg.projects[repoPath] = {
        storageName,
        storagePath,
        lastUsed: new Date().toISOString()
    };

    // Set active project
    cfg.activeProject = repoPath;
    config.writeConfig(cfg);

    return repoPath;
});

// 2️⃣ Get folder tree
ipcMain.handle('getFolderTree', async (event, repoPath) => {
    if (!repoPath) return [];

    const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);
    return fileOps.getFolderTree(repoPath, ignoreRules);
});

// 3️⃣ Generate structure/code
ipcMain.handle('generate', async (event, actionType, repoPath, items, fileName) => {
    if (!repoPath || !items.length || !fileName) return;

    const activeProject = config.getActiveProject();
    if (!activeProject) {
        dialog.showErrorBox('Error', 'No active project found in config.');
        return;
    }

    const storagePath = activeProject.storagePath;
    const outputFolder = actionType === 'code'
        ? path.join(storagePath, 'Codes')
        : path.join(storagePath, 'Structures');

    if (!fs.existsSync(outputFolder)) fs.mkdirSync(outputFolder, { recursive: true });

    const outputFile = path.join(outputFolder, fileName);
    const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);

    if (actionType === 'structure') {
        await fileOps.generateStructure(items, outputFile, ignoreRules, (percent) => {
            mainWindow.webContents.send('progress-update', percent);
        });
    } else if (actionType === 'code') {
        await codeOps.generateCode(items, outputFile, (percent) => {
            mainWindow.webContents.send('progress-update', percent);
        }, repoPath, ignoreRules);
    }

    return true;
});

// 4️⃣ Get .docignore rules
ipcMain.handle('get-docignore', async (event, repoPath) => {
    if (!repoPath) return [];
    return await docignoreUtils.getIgnoreRules(repoPath);
});

ipcMain.handle('get-active-project', () => {
    const activeProjectPath = config.readConfig().activeProject; // this is the real repo folder
    if (!activeProjectPath) return null;

    const projectData = config.readConfig().projects[activeProjectPath];
    return {
        repoPath: activeProjectPath,    // <-- real folder path
        ...projectData
    };
});


// ✅ IPC: get last selected items
ipcMain.handle('get-last-selected', () => {
    return config.getLastSelectedItems();
});

// ✅ IPC: save last selected items
ipcMain.handle('set-last-selected', (event, items) => {
    config.setLastSelectedItems(items);
});


------------------------------
FILE: preload.js

const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
    selectRepo: () => ipcRenderer.invoke('select-repo'),
    getFolderTree: (repoPath) => ipcRenderer.invoke('getFolderTree', repoPath),
    generate: (actionType, repoPath, items, fileName, onProgress) => {
        return ipcRenderer.invoke('generate', actionType, repoPath, items, fileName)
            .then(() => { if (onProgress) onProgress(100); });
    },
    openStorage: () => ipcRenderer.invoke('open-storage'),
    onProgressUpdate: (callback) => ipcRenderer.on('progress-update', (event, percent) => callback(percent)),
    getDocignore: (repoPath) => ipcRenderer.invoke('get-docignore', repoPath),
    getLastSelected: () => ipcRenderer.invoke('get-last-selected'),
    setLastSelected: (items) => ipcRenderer.invoke('set-last-selected', items),
    getActiveProject: () => ipcRenderer.invoke('get-active-project')
});


------------------------------
FILE: renderer\app.js

const selectRepoBtn = document.getElementById('selectRepoBtn');
const activeRepoName = document.getElementById('activeRepoName');
const treeContainer = document.getElementById('treeContainer');
const structureBtn = document.getElementById('structureBtn');
const codeBtn = document.getElementById('codeBtn');
const generateBtn = document.getElementById('generateBtn');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

let selectedRepoPath = null;
let selectedItems = [];
let actionType = 'code';
let cachedTree = null;

// --------------------
// UI setup
// --------------------
treeContainer.style.overflowY = 'auto';
treeContainer.style.maxHeight = '80vh';
generateBtn.disabled = true;

// --------------------
// Progress listener
// --------------------
window.electronAPI.onProgressUpdate((percent) => {
    progressBar.value = percent;
    progressText.textContent = `${percent}%`;
});

// --------------------
// Helpers
// --------------------
function updateActiveRepo(name) {
    activeRepoName.textContent = name || 'No repo selected';
}

function updateGenerateState() {
    generateBtn.disabled = selectedItems.length === 0;
}

function countFiles(node) {
    if (node.type === 'file') return 1;
    if (!node.children?.length) return 0;
    return node.children.reduce((acc, child) => acc + countFiles(child), 0);
}

// --------------------
// Load last repo
// --------------------
async function loadLastActiveRepo() {
    const lastRepoPath = await window.electronAPI.getActiveProjectPath?.();
    if (lastRepoPath) {
        await loadRepo(lastRepoPath);
    }
}

// --------------------
// Repo selection
// --------------------
selectRepoBtn.addEventListener('click', async () => {
    const repoPath = await window.electronAPI.selectRepo();
    if (repoPath) {
        await loadRepo(repoPath);
    }
});

async function loadRepo(repoPath) {
    selectedRepoPath = repoPath;

    const repoName = repoPath.split(/[/\\]/).pop();
    updateActiveRepo(repoName);

    cachedTree = await window.electronAPI.getFolderTree(repoPath);
    selectedItems = (await window.electronAPI.getLastSelected()) || [];

    updateGenerateState();
    displayTree(cachedTree, treeContainer, actionType);
}

// --------------------
// Tree rendering
// --------------------
function displayTree(tree, container, mode) {
    container.innerHTML = '';

    function createNode(node) {
        if (mode === 'structure' && node.type === 'file') return null;

        const el = document.createElement('div');
        el.classList.add('tree-node');
        el.style.cursor = 'pointer';
        el.style.paddingLeft = '16px';
        el.style.userSelect = 'none';
        el.style.fontSize = '14px';

        if (node.type === 'file') el.classList.add('file');

        const isSelected = selectedItems.includes(node.path);
        if (isSelected) el.classList.add('selected');

        if (node.type === 'folder' && actionType === 'code' && isSelected) {
            el.classList.add('folder-selected');
        }

        let label = node.name;

        if (node.type === 'folder' && node.children?.length && mode !== 'structure') {
            const fileCount = countFiles(node);
            if (fileCount > 0) label += ` (${fileCount} files)`;
        }

        if (node.type === 'folder' && actionType === 'code' && isSelected) {
            label += ' [ALL FILES]';
        }

        el.textContent = label;

        el.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSelect(node);
        });

        if (node.type === 'folder' && node.children?.length) {
            const childrenContainer = document.createElement('div');
            childrenContainer.classList.add('children');
            childrenContainer.style.marginLeft = '16px';

            node.children.forEach(child => {
                const childNode = createNode(child);
                if (childNode) childrenContainer.appendChild(childNode);
            });

            el.appendChild(childrenContainer);
        }

        return el;
    }

    tree.forEach(node => {
        const n = createNode(node);
        if (n) container.appendChild(n);
    });
}

// --------------------
// Selection logic
// --------------------
function toggleSelect(node) {
    if (!selectedRepoPath) return;

    const isSelected = selectedItems.includes(node.path);

    if (isSelected) {
        selectedItems = selectedItems.filter(p => p !== node.path);
    } else {
        selectedItems.push(node.path);
    }

    window.electronAPI.setLastSelected(selectedItems);
    updateGenerateState();

    // Re-render from cache to update labels
    if (node.type === 'folder' && actionType === 'code') {
        displayTree(cachedTree, treeContainer, actionType);
    }
}

// --------------------
// Mode switching
// --------------------
function resetSelection() {
    selectedItems = [];
    window.electronAPI.setLastSelected([]);
    updateGenerateState();
}

structureBtn.addEventListener('click', async () => {
    actionType = 'structure';
    resetSelection();

    if (!selectedRepoPath) return;
    displayTree(cachedTree, treeContainer, actionType);
});

codeBtn.addEventListener('click', async () => {
    actionType = 'code';
    resetSelection();

    if (!selectedRepoPath) return;
    displayTree(cachedTree, treeContainer, actionType);
});

// --------------------
// Generate
// --------------------
generateBtn.addEventListener('click', async () => {
    if (!selectedRepoPath || !selectedItems.length) {
        return alert('Select repo and items first!');
    }

    const fileName = prompt('Enter output file name (e.g., UserModule.txt):');
    if (!fileName) return;

    progressBar.value = 0;
    progressText.textContent = '0%';

    await window.electronAPI.generate(
        actionType,
        selectedRepoPath,
        selectedItems,
        fileName
    );

    alert('Done!');
    resetSelection();
    displayTree(cachedTree, treeContainer, actionType);
});

// --------------------
// Init
// --------------------
window.addEventListener('DOMContentLoaded', loadLastActiveRepo);


------------------------------
FILE: renderer\index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Helper Tool</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="app">
    <h1>Helper Tool</h1>

    <!-- Repo selection -->
    <div class="section">
      <button id="selectRepoBtn">Select Repo</button>
      <span id="activeRepoName">No repo selected</span>
    </div>

    <!-- Tree view -->
    <div class="section">
      <h2>Project Tree</h2>
      <div id="treeContainer">Select a repo to view files</div>
    </div>

    <!-- Action buttons -->
    <div class="section">
      <button id="structureBtn" class="action-btn">Structure</button>
      <button id="codeBtn" class="action-btn">Code</button>
      <button id="generateBtn" class="action-btn">Done / Generate</button>
    </div>

    <!-- Progress -->
    <div class="section">
      <progress id="progressBar" value="0" max="100"></progress>
      <span id="progressText">0%</span>
    </div>
  </div>

  <script src="app.js"></script>
</body>
</html>


------------------------------
FILE: renderer\style.css

/* Reset some default styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* Body styling */
body {
  background-color: #f5f6fa;
  color: #333;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  padding: 40px 20px;
}

/* App container */
#app {
  background-color: #fff;
  padding: 30px 40px;
  border-radius: 12px;
  box-shadow: 0 6px 20px rgba(0,0,0,0.1);
  width: 100%;
  max-width: 600px;
}

/* Main title */
#app h1 {
  text-align: center;
  margin-bottom: 30px;
  font-size: 2rem;
  color: #2f3640;
}

/* Section styling */
.section {
  margin-bottom: 25px;
}

/* Buttons */
button {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  background-color: #0984e3;
  color: #fff;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s ease, transform 0.1s ease;
}

button:hover {
  background-color: #74b9ff;
  transform: translateY(-2px);
}

button:active {
  transform: translateY(0);
}

/* Action buttons spacing */
.action-btn {
  margin-right: 10px;
}

/* Active repo text */
#activeRepoName {
  margin-left: 15px;
  font-weight: 500;
  color: #636e72;
}

/* Tree container */
#treeContainer {
  margin-top: 10px;
  padding: 15px;
  background-color: #dfe6e9;
  border-radius: 8px;
  min-height: 100px;
  overflow-y: auto;
  font-family: monospace;
  font-size: 0.95rem;
}

/* Progress bar container */
progress {
  width: 100%;
  height: 20px;
  -webkit-appearance: none;
  appearance: none;
  border-radius: 10px;
  overflow: hidden;
}

progress::-webkit-progress-bar {
  background-color: #dfe6e9;
}

progress::-webkit-progress-value {
  background-color: #00b894;
}

progress::-moz-progress-bar {
  background-color: #00b894;
}

#progressText {
  display: inline-block;
  margin-left: 10px;
  font-weight: 500;
  color: #2d3436;
}

/* Responsive tweaks */
@media (max-width: 480px) {
  #app {
    padding: 20px;
  }

  button {
    width: 100%;
    margin-bottom: 10px;
  }

  .action-btn {
    margin-right: 0;
  }
}

/* style.css */

/* General tree container */
#treeContainer {
  font-family: monospace;
  white-space: pre;
  border: 1px solid #ccc;
  padding: 8px;
  max-height: 400px;
  overflow-y: auto;
  background: #f9f9f9;
}

/* Each node */
.tree-node {
  padding: 2px 4px;
  border-radius: 4px;
  margin: 1px 0;
}

/* Hover effect */
.tree-node:hover {
  background-color: #eef;
}

/* Children nodes */
.children {
  margin-left: 16px; /* Indent children */
}

/* Selected node */
.tree-node.selected {
  background-color: #d0f0d0;
  font-weight: bold;
}

/* Files smaller than folders */
.tree-node.file {
  font-size: 0.9em;
}

.tree-node.selected {
  background-color: #d0f0d0;
}

.tree-node.folder-selected {
  font-weight: bold;
}



------------------------------
FILE: utils\codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect all file paths from a folder, respecting ignore rules
 */
function getAllFiles(folderPath, ignoreRules = [], repoRoot) {
    let files = [];
    if (!fs.existsSync(folderPath)) return files;

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (item.isDirectory()) {
            files = files.concat(getAllFiles(fullPath, ignoreRules, repoRoot));
        } else if (item.isFile()) {
            files.push(fullPath);
        }
    }

    return files;
}

/**
 * Generate code file by combining multiple selected folders/files
 * @param {Array<string>} selectedItems - files or folders
 * @param {string} outputFile
 * @param {Function} onProgress - callback(percent)
 * @param {string} repoRoot - repo root path
 * @param {Array<string>} ignoreRules - optional ignore rules
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}, repoRoot, ignoreRules = []) {
    if (!selectedItems.length) return;
    if (!repoRoot) repoRoot = path.dirname(selectedItems[0]);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles = allFiles.concat(getAllFiles(item, ignoreRules, repoRoot));
        else if (stat.isFile() && !isIgnored(item, repoRoot, ignoreRules)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        writeStream.write(`\n// ===== File: ${path.relative(repoRoot, filePath)} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }
    writeStream.close();
}


module.exports = {
    generateCode
};


------------------------------
FILE: utils\docignore.js

const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch'); // npm install micromatch

/**
 * Read .docignore file from repo
 * @param {string} repoPath - path to the repo
 * @returns {Promise<string[]>} - array of patterns to ignore
 */
async function getIgnoreRules(repoPath) {
    const cfg = path.join(repoPath, '.docignore');
    if (!fs.existsSync(cfg)) return [];
    return fs.readFileSync(cfg, 'utf-8')
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'));
}


/**
 * Check if a given file/folder path should be ignored
 * @param {string} fullPath - absolute path of file/folder
 * @param {string} repoPath - root repo path
 * @param {Array<string>} ignoreRules - array of patterns from getIgnoreRules
 * @returns {boolean}
 */
function isIgnored(fullPath, repoPath, ignoreRules) {
    const relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');
    return micromatch.isMatch(relPath, ignoreRules, { dot: true });
}
module.exports = { getIgnoreRules, isIgnored };


------------------------------
FILE: utils\fileOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored } = require('./docignore');

function getFolderTree(dir, ignoreRules = [], repoRoot = dir) {
    return fs.readdirSync(dir, { withFileTypes: true })
        .filter(f => !isIgnored(path.join(dir, f.name), repoRoot, ignoreRules))
        .map(f => f.isDirectory()
            ? { name: f.name, path: path.join(dir, f.name), type: 'folder', children: getFolderTree(path.join(dir, f.name), ignoreRules, repoRoot) }
            : { name: f.name, path: path.join(dir, f.name), type: 'file' }
        );
}

async function generateStructure(selectedPaths, outputFile, ignoreRules = [], progressCallback = () => {}) {
    let output = '';
    const allItems = [];

    function collect(p, repoRoot) {
        if (isIgnored(p, repoRoot, ignoreRules)) return;
        allItems.push(p);
        if (fs.statSync(p).isDirectory())
            fs.readdirSync(p).forEach(c => collect(path.join(p, c), repoRoot));
    }

    selectedPaths.forEach(p => collect(p, p));

    allItems.forEach((p, idx) => {
        const stat = fs.statSync(p);
        output += `${'  '.repeat(p.split(path.sep).length)}${path.basename(p)}${stat.isDirectory() ? '/' : ''}\n`;
        progressCallback(Math.round(((idx + 1) / allItems.length) * 100));
    });

    fs.writeFileSync(outputFile, output, 'utf-8');
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: utils\treeView.js



