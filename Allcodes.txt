------------------------------
FILE: config\config.js

const fs = require('fs');
const path = require('path');
const { app } = require('electron');

const CONFIG_PATH = path.join(__dirname, 'helper-config.json');

function readConfig() {
    if (!fs.existsSync(CONFIG_PATH)) {
        const defaultConfig = {
            baseStoragePath: path.join(app.getPath('userData'), 'HelperToolStorage'),
            activeProject: null,
            projects: {},
            preferences: {
                docignoreFileName: ".docignore",
                showHiddenFiles: false,
                defaultStructureView: "tree",
                autoSelectLastProject: true
            }
        };
        fs.writeFileSync(CONFIG_PATH, JSON.stringify(defaultConfig, null, 2));
        return defaultConfig;
    }
    return JSON.parse(fs.readFileSync(CONFIG_PATH));
}

function writeConfig(config) {
    fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2));
}

function getActiveProject() {
    const config = readConfig();
    if (config.activeProject) {
        return config.projects[config.activeProject];
    }
    return null;
}

function getLastSelectedItems() {
    const project = getActiveProject();
    return project?.lastSelectedItems || [];
}

function setLastSelectedItems(items) {
    const cfg = readConfig();
    if (cfg.activeProject && cfg.projects[cfg.activeProject]) {
        cfg.projects[cfg.activeProject].lastSelectedItems = items;
        writeConfig(cfg);
    }
}

function ensureStorageFolder(storagePath) {
    if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
    ['Codes', 'Structures'].forEach(sub => {
        const subPath = path.join(storagePath, sub);
        if (!fs.existsSync(subPath)) fs.mkdirSync(subPath);
    });
    return storagePath;
}

module.exports = { 
    readConfig, 
    writeConfig, 
    getActiveProject, 
    getLastSelectedItems,
    setLastSelectedItems,
    ensureStorageFolder
};


------------------------------
FILE: config\helper-config.json

{
  "baseStoragePath": "C:/Users/Windows10/Desktop/HelperToolStorage",
  "activeProject": "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\Chatly",
  "projects": {
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduTool\\client\\src": {
      "storageName": "src",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\src",
      "lastUsed": "2026-01-05T10:06:31.639Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\backend": {
      "storageName": "backend",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\backend",
      "lastUsed": "2026-01-05T10:06:54.589Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Parallel\\Guitar-store": {
      "storageName": "Guitar-store",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Guitar-store",
      "lastUsed": "2026-01-05T10:34:07.131Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown": {
      "storageName": "Gown",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Gown",
      "lastUsed": "2026-01-06T02:17:56.102Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\Jollibee": {
      "storageName": "Jollibee",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Jollibee",
      "lastUsed": "2026-01-05T14:42:20.003Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Excalidraw": {
      "storageName": "Excalidraw",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Excalidraw",
      "lastUsed": "2026-01-06T02:17:34.325Z",
      "lastSelectedItems": [
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Excalidraw\\Labdoc.excalidraw"
      ]
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EventDrivenArchitecture": {
      "storageName": "EventDrivenArchitecture",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\EventDrivenArchitecture",
      "lastUsed": "2026-01-06T03:10:54.347Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\STUDYLY": {
      "storageName": "STUDYLY",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\STUDYLY",
      "lastUsed": "2026-01-06T03:21:11.358Z",
      "lastSelectedItems": [
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\STUDYLY\\Presentation"
      ]
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduToolV2": {
      "storageName": "EduToolV2",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\EduToolV2",
      "lastUsed": "2026-01-06T03:24:49.189Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\Chatly": {
      "storageName": "Chatly",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Chatly",
      "lastUsed": "2026-01-07T12:51:48.286Z",
      "lastSelectedItems": []
    }
  },
  "preferences": {
    "docignoreFileName": ".docignore",
    "showHiddenFiles": false,
    "defaultStructureView": "tree",
    "autoSelectLastProject": true
  }
}

------------------------------
FILE: main.js

const { app, BrowserWindow, Tray, Menu, ipcMain, shell, dialog } = require('electron');
const path = require('path');
const fs = require('fs');
const config = require('./config/config.js');
const { exec } = require('child_process'); 

// Utils
const fileOps = require('./utils/fileOps.js');
const docignoreUtils = require('./utils/docignore.js');
const codeOps = require('./utils/codeOps.js');


let mainWindow;
let tray;

function createWindow() {
    console.log('[Main] Creating main window...');
    mainWindow = new BrowserWindow({
        width: 1920,
        height: 1080,
        show: true,
        frame: true,  // Show normal window frame with buttons
        maximizable: true,
        minimizable: true,  // Allow minimize
        webPreferences: {
            preload: path.join(__dirname, 'preload.js')
        }
    });

    mainWindow.loadFile(path.join(__dirname, 'renderer', 'index.html'));
    
    // Maximize on start
    mainWindow.maximize();

    mainWindow.on('close', (e) => {
        e.preventDefault();
        mainWindow.hide();
        console.log('[Main] Main window hidden instead of close');
    });
}
// ----------------------------
// App Ready
// ----------------------------
app.whenReady().then(() => {
    console.log('[Main] App is ready');
    createTray();
    createWindow();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });
});

// ----------------------------
// Tray
// ----------------------------
function createTray() {
    console.log('[Tray] Creating tray icon...');
    tray = new Tray(path.join(__dirname, 'assets', 'tray-icon.png'));

    const contextMenu = Menu.buildFromTemplate([
        { label: 'Open Helper', click: () => mainWindow.show() },
        { label: 'Open Storage Folder', click: () => openStorage() },
        { type: 'separator' },
        { label: 'Select Previous Repo', submenu: getPreviousReposMenu() },
        { type: 'separator' },
        { label: 'Exit', click: () => app.quit() }
    ]);

    tray.setToolTip('Helper Tool');
    tray.setContextMenu(contextMenu);
    console.log('[Tray] Tray menu created');
}

// main.js additions
ipcMain.handle('open-global-docignore', async () => {
    try {
        const globalDocignorePath = path.join(app.getPath('userData'), 'global-docignore.json');

        // Create file if it doesn't exist
        if (!fs.existsSync(globalDocignorePath)) {
            fs.writeFileSync(globalDocignorePath, JSON.stringify([], null, 2), 'utf-8');
            console.log('[Main] Created new global-docignore.json at', globalDocignorePath);
        } else {
            console.log('[Main] global-docignore.json exists at', globalDocignorePath);
        }

        // Open with default editor
        await shell.openPath(globalDocignorePath);
        console.log('[Main] global-docignore.json opened');
        return true;
    } catch (err) {
        console.error('[Main] Failed to open global-docignore.json:', err);
        return false;
    }
});

ipcMain.handle('open-storage', async () => {
    try {
        openStorage(); // just reuse the existing function
        return true;
    } catch (err) {
        console.error('[IPC] open-storage failed:', err);
        return false;
    }
});


// ----------------------------
// Previous Repos Menu
// ----------------------------
function getPreviousReposMenu() {
    const cfg = config.readConfig();
    const submenu = [];

    for (const repoPath in cfg.projects) {
        submenu.push({
            label: path.basename(repoPath),
            click: () => {
                console.log('[Tray] Setting active project:', repoPath);
                cfg.activeProject = repoPath;
                config.writeConfig(cfg);
            }
        });
    }

    if (submenu.length === 0) {
        submenu.push({ label: 'No previous repos', enabled: false });
        console.log('[Tray] No previous repos found');
    }

    return submenu;
}

// ----------------------------
// Open Storage Folder
// ----------------------------
function openStorage() {
    try {
        const activeProject = config.getActiveProject();
        if (activeProject) {
            const storagePath = activeProject.storagePath;
            console.log('[Storage] Opening storage folder:', storagePath);
            if (fs.existsSync(storagePath)) {
                shell.openPath(storagePath);
            } else {
                console.warn('[Storage] Storage folder does not exist:', storagePath);
                dialog.showErrorBox('Storage Not Found', 'Storage folder does not exist.');
            }
        } else {
            console.warn('[Storage] No active project');
            dialog.showErrorBox('No Active Project', 'Select a project first.');
        }
    } catch (err) {
        console.error('[Error] openStorage failed:', err);
    }
}

// ----------------------------
// IPC Handlers
// ----------------------------

// Select repo
ipcMain.handle('select-repo', async () => {
    try {
        console.log('[IPC] select-repo called');
        const result = await dialog.showOpenDialog({ properties: ['openDirectory'] });

        if (result.canceled || !result.filePaths.length) {
            console.log('[IPC] Repo selection cancelled');
            return null;
        }

        const repoPath = result.filePaths[0];
        console.log('[IPC] Repo selected:', repoPath);

        const cfg = config.readConfig();
        const storageName = path.basename(repoPath).replace(/[^a-zA-Z0-9-_]/g, '_');
        const userDataPath = app.getPath('userData');
        const storagePath = path.join(userDataPath, storageName);

        // Create storage folders
        if (!fs.existsSync(userDataPath)) fs.mkdirSync(userDataPath, { recursive: true });
        if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
        ['Codes', 'Structures'].forEach(sub => {
            const subPath = path.join(storagePath, sub);
            if (!fs.existsSync(subPath)) fs.mkdirSync(subPath, { recursive: true });
        });
        console.log('[IPC] Storage folders ensured at:', storagePath);

        // Update config
        cfg.projects[repoPath] = {
            storageName,
            storagePath,
            lastUsed: new Date().toISOString()
        };
        cfg.activeProject = repoPath;
        config.writeConfig(cfg);
        console.log('[IPC] Config updated for repo:', repoPath);

        return repoPath;
    } catch (err) {
        console.error('[IPC] select-repo error:', err);
        dialog.showErrorBox('Select Repo Error', err.message);
        return null;
    }
});

ipcMain.handle('getFolderTree', async (event, repoPath) => {
    try {
        console.log('[IPC] getFolderTree called for:', repoPath);
        if (!repoPath) return [];

        // Load ignore rules
        const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);
        console.log('[IPC] Ignore rules loaded:', ignoreRules.length);
        
        // IMPORTANT: AWAIT the tree generation!
        const tree = await fileOps.getFolderTree(repoPath);
        console.log('[IPC] Tree generated, root items:', tree.length);
        
        return tree;
    } catch (err) {
        console.error('[IPC] getFolderTree error:', err);
        return [];
    }
});
ipcMain.handle('get-user-data-path', () => app.getPath('userData'));


ipcMain.handle('generate', async (event, actionType, repoPath, items, filePath) => {
    try {
        console.log('[IPC] generate called:', { actionType, repoPath, itemsLength: items?.length, filePath });
        if (!repoPath || !items?.length || !filePath) throw new Error('Invalid arguments');

        const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);

        // Ensure the directory of the output file exists
        const outputDir = path.dirname(filePath);
        if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

        if (actionType === 'structure') {
            console.log('[IPC] Generating structure...');
await fileOps.generateStructure(items, filePath, (percent) => {
    mainWindow.webContents.send('progress-update', percent);
});

        } else if (actionType === 'code') {
            console.log('[IPC] Generating code...');
            await codeOps.generateCode(items, filePath, (percent) => {
                mainWindow.webContents.send('progress-update', percent);
                //console.log(`[Progress] ${percent}%`);
            }, repoPath, ignoreRules);
        }

        console.log(`[IPC] Generation complete. Output at: ${filePath}`);

        // --------------------------
        // OPEN NOTEPAD AUTOMATICALLY
        // --------------------------
        exec(`notepad "${filePath}"`, (err) => {
            if (err) console.error('[IPC] Failed to open Notepad:', err);
        });

        return true;
    } catch (err) {
        console.error('[IPC] generate error:', err);
        dialog.showErrorBox('Generate Error', err.message);
        return false;
    }
});
// ----------------------------
// Open .docignore file
// ----------------------------
ipcMain.handle('open-docignore', async (event, repoPath) => {
    try {
        if (!repoPath) return false;
        const docignoreFile = path.join(repoPath, '.docignore');

        // If file doesn't exist, create empty
        if (!fs.existsSync(docignoreFile)) {
            fs.writeFileSync(docignoreFile, '# Add patterns to ignore files/folders\n', 'utf-8');
        }

        // Open with default editor
        shell.openPath(docignoreFile);
        console.log('[Main] .docignore opened:', docignoreFile);
        return true;
    } catch (err) {
        console.error('[IPC] open-docignore error:', err);
        return false;
    }
});


// Get .docignore rules
ipcMain.handle('get-docignore', async (event, repoPath) => {
    try {
        console.log('[IPC] get-docignore called for:', repoPath);
        if (!repoPath) return [];
        return await docignoreUtils.getIgnoreRules(repoPath);
    } catch (err) {
        console.error('[IPC] get-docignore error:', err);
        return [];
    }
});

// Get active project
ipcMain.handle('get-active-project', () => {
    try {
        console.log('[IPC] get-active-project called');
        const activeProjectPath = config.readConfig().activeProject;
        if (!activeProjectPath) return null;
        const projectData = config.readConfig().projects[activeProjectPath];
        console.log('[IPC] Active project data:', projectData);
        return { repoPath: activeProjectPath, ...projectData };
    } catch (err) {
        console.error('[IPC] get-active-project error:', err);
        return null;
    }
});

// Get last selected items
ipcMain.handle('get-last-selected', () => {
    try {
        const items = config.getLastSelectedItems();
        console.log('[IPC] get-last-selected:', items);
        return items;
    } catch (err) {
        console.error('[IPC] get-last-selected error:', err);
        return [];
    }
});

// Set last selected items
ipcMain.handle('set-last-selected', (event, items) => {
    try {
        console.log('[IPC] set-last-selected:', items);
        config.setLastSelectedItems(items);
    } catch (err) {
        console.error('[IPC] set-last-selected error:', err);
    }
});

ipcMain.handle('save-file-dialog', async (event, actionType) => {
    const activeProject = config.getActiveProject();
    if (!activeProject) return { filePath: null };

    const defaultFolder = path.join(
        activeProject.storagePath,
        actionType === 'code' ? 'Codes' : 'Structures'
    );

    const result = await dialog.showSaveDialog({
        title: 'Enter output file name',
        defaultPath: path.join(defaultFolder, 'output.txt'),
        buttonLabel: 'Save'
    });

    return { filePath: result.canceled ? null : result.filePath };
});


------------------------------
FILE: preload.js

// preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
    // ------------------------
    // Repo selection
    // ------------------------
    selectRepo: () => ipcRenderer.invoke('select-repo'),

    // ------------------------
    // Folder tree
    // ------------------------
    getFolderTree: (repoPath) => ipcRenderer.invoke('getFolderTree', repoPath),

    // ------------------------
    // Generate structure/code
    // ------------------------
    generate: (actionType, repoPath, items, filePath) => {
        return ipcRenderer.invoke('generate', actionType, repoPath, items, filePath);
    },

    // ------------------------
    // Open storage folder
    // ------------------------
    openStorage: () => ipcRenderer.invoke('open-storage'),
    openDocignore: (repoPath) => ipcRenderer.invoke('open-docignore', repoPath),
    getUserDataPath: () => ipcRenderer.invoke('get-user-data-path'),
    openGlobalDocignore: () => ipcRenderer.invoke('open-global-docignore'),

    // ------------------------
    // Progress updates
    // ------------------------
    onProgressUpdate: (callback) => {
        ipcRenderer.removeAllListeners('progress-update'); // avoid duplicate callbacks
        ipcRenderer.on('progress-update', (event, percent) => {
            const validPercent = Math.min(Math.max(Math.round(percent), 0), 100);
            callback(validPercent);
        });
    },

    // ------------------------
    // .docignore
    // ------------------------
    getDocignore: (repoPath) => ipcRenderer.invoke('get-docignore', repoPath),

    // ------------------------
    // Last selected items
    // ------------------------
    getLastSelected: () => ipcRenderer.invoke('get-last-selected'),
    setLastSelected: (items) => ipcRenderer.invoke('set-last-selected', items),

    // ------------------------
    // Active project
    // ------------------------
    getActiveProject: () => ipcRenderer.invoke('get-active-project'),

    // ------------------------
    // Save file dialog (new)
    // ------------------------
    saveFileDialog: (actionType) => ipcRenderer.invoke('save-file-dialog', actionType)
});


------------------------------
FILE: renderer\app.js

import { renderTree } from '../utils/treeView.js';

const selectRepoBtn = document.getElementById('selectRepoBtn');
const activeRepoName = document.getElementById('activeRepoName');
const treeContainer = document.getElementById('treeContainer');
const structureBtn = document.getElementById('structureBtn');
const codeBtn = document.getElementById('codeBtn');
const generateBtn = document.getElementById('generateBtn');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const openStorageBtn = document.getElementById('openStorageBtn');
const editDocignoreBtn = document.getElementById('editDocignoreBtn');
const treeSearchInput = document.getElementById('treeSearchInput');
const searchSuggestions = document.getElementById('searchSuggestions');

let selectedRepoPath = null;
let selectedItems = [];        
let actionType = 'code';
let cachedTree = null;

/* ----------------------------------------
 * UI setup
 * -------------------------------------- */
console.log('[Init] Setting up UI...');
treeContainer.style.overflowY = 'auto';
treeContainer.style.maxHeight = '80vh';
generateBtn.disabled = true;

/* ----------------------------------------
 * Progress listener
 * -------------------------------------- */
window.electronAPI.onProgressUpdate(percent => {
    console.log(`[Progress] ${percent}%`);
    progressBar.value = percent;
    progressText.textContent = `${percent}%`;
});

/* ----------------------------------------
 * Helpers
 * -------------------------------------- */
function updateActiveRepo(name) {
    console.log(`[UI] Active repo updated: ${name || 'No repo selected'}`);
    activeRepoName.textContent = name || 'No repo selected';
}

function updateGenerateState() {
    console.log(`[UI] Generate button ${selectedItems.length === 0 ? 'disabled' : 'enabled'}`);
    generateBtn.disabled = selectedItems.length === 0;
}

/* ----------------------------------------
 * Tree selection callback
 * -------------------------------------- */
function onTreeSelectionChange() {
    console.log('[Tree] Selection changed:', selectedItems);
    updateGenerateState();
    window.electronAPI.setLastSelected(selectedItems);
}

/* ----------------------------------------
 * Open storage
 * -------------------------------------- */
openStorageBtn.addEventListener('click', async () => {
    console.log('[UI] Open storage clicked');
    try {
        await window.electronAPI.openStorage();
        console.log('[UI] Storage opened');
    } catch (err) {
        console.error('[UI] Failed to open storage:', err);
        alert('Failed to open storage.');
    }
});

/* ----------------------------------------
 * Load last active repo
 * -------------------------------------- */
async function loadLastActiveRepo() {
    console.log('[Init] Loading last active repo...');
    try {
        const project = await window.electronAPI.getActiveProject();
        console.log('[Init] Last project data:', project);

        if (project?.repoPath) {
            selectedItems.length = 0;
            project.lastSelectedItems?.forEach(p => selectedItems.push(p));

            await loadRepo(project.repoPath, false);
        }
    } catch (err) {
        console.error('[Init] Failed to load last project:', err);
    }
}

/* ----------------------------------------
 * Select repo
 * -------------------------------------- */
selectRepoBtn.addEventListener('click', async () => {
    console.log('[UI] Select repo clicked');
    try {
        const repoPath = await window.electronAPI.selectRepo();
        console.log('[UI] Repo selected:', repoPath);
        if (repoPath) await loadRepo(repoPath);
    } catch (err) {
        console.error('[UI] Repo selection failed:', err);
    }
});

/* ----------------------------------------
 * Load repo
 * -------------------------------------- */
async function loadRepo(repoPath, resetSelection = true) {
    console.log('[Repo] Loading repo:', repoPath);
    selectedRepoPath = repoPath;

    if (resetSelection) {
        selectedItems.length = 0;
        await window.electronAPI.setLastSelected([]);
        console.log('[Repo] Selection reset');
    }

    updateActiveRepo(repoPath.split(/[/\\]/).pop());

    cachedTree = await window.electronAPI.getFolderTree(repoPath);
    console.log('[Repo] Tree data loaded:', cachedTree);
    displayTree();
    updateGenerateState();
}

/* ----------------------------------------
 * Display tree
 * -------------------------------------- */
function displayTree() {
    console.log('[Tree] Displaying tree...');
    if (!cachedTree) {
        treeContainer.textContent = 'No data available';
        console.log('[Tree] No tree data');
        return;
    }

    renderTree(
        cachedTree,
        treeContainer,
        selectedItems,
        actionType,
        onTreeSelectionChange
    );
    console.log('[Tree] Tree rendered');
}

/* ----------------------------------------
 * Mode switching
 * -------------------------------------- */
function resetSelection() {
    selectedItems.length = 0;
    window.electronAPI.setLastSelected([]);
    console.log('[UI] Selection reset');
    updateGenerateState();
}

structureBtn.addEventListener('click', () => {
    actionType = 'structure';
    console.log('[UI] Switched to structure mode');
    resetSelection();
    displayTree();
});

codeBtn.addEventListener('click', () => {
    actionType = 'code';
    console.log('[UI] Switched to code mode');
    resetSelection();
    displayTree();
});

/* ----------------------------------------
 * Edit .docignore
 * -------------------------------------- */
editDocignoreBtn.addEventListener('click', async () => {
    console.log('[UI] Edit .docignore clicked');
    try {
        const ok = await window.electronAPI.openGlobalDocignore();
        console.log('[UI] .docignore opened:', ok);
        if (!ok) alert('Failed to open global ignore file.');
    } catch (err) {
        console.error('[UI] Error opening .docignore:', err);
    }
});

/* ----------------------------------------
 * Generate
 * -------------------------------------- */
generateBtn.addEventListener('click', async () => {
    console.log('[UI] Generate clicked');
    try {
        if (!selectedRepoPath || !selectedItems.length) {
            return alert('Select repo and items first!');
        }

        const { filePath } = await window.electronAPI.saveFileDialog(actionType);
        console.log('[UI] Save file dialog result:', filePath);
        if (!filePath) return;

        progressBar.value = 0;
        progressText.textContent = '0%';

        const success = await window.electronAPI.generate(
            actionType,
            selectedRepoPath,
            selectedItems,
            filePath
        );

        if (success) {
            console.log(`[UI] Generation complete. File should open in VS Code or default editor: ${filePath}`);
        } else {
            alert('Generation failed.');
        }

        resetSelection();
        displayTree();
    } catch (err) {
        console.error('[Generate] Failed:', err);
        alert('Generation failed.');
    }
});

/* ----------------------------------------
 * Tree search
 * -------------------------------------- */
function flattenTree(tree, result = []) {
    for (const node of tree) {
        result.push(node);
        if (node.children?.length) flattenTree(node.children, result);
    }
    return result;
}

function expandPathParents(path) {
    let target = document.querySelector(`[data-node-path='${path}']`);
    while (target) {
        const wrapper = target.closest('.node-wrapper');
        if (!wrapper) break;
        const childrenContainer = wrapper.querySelector('.children');
        if (childrenContainer) childrenContainer.style.display = 'flex';
        const folderNode = wrapper.querySelector('.tree-node.folder');
        if (folderNode) folderNode.classList.add('folder-open');
        target = wrapper.parentElement.closest('.tree-node');
    }
}

function searchTree(query) {
    console.log('[Search] Query:', query);
    if (!cachedTree || !query) {
        searchSuggestions.style.display = 'none';
        console.log('[Search] No results, tree empty or query empty');
        return;
    }

    const flatList = flattenTree(cachedTree);
    const matches = flatList.filter(node => 
        node.name.toLowerCase().includes(query.toLowerCase())
    );

    console.log('[Search] Matches:', matches.map(m => m.name));

    searchSuggestions.innerHTML = '';
    matches.slice(0, 10).forEach(node => {
        const li = document.createElement('li');
        li.textContent = node.name;
        li.dataset.path = node.path;
        li.addEventListener('click', () => {
            selectSearchItem(node.path);
            searchSuggestions.style.display = 'none';
            treeSearchInput.value = '';
        });
        searchSuggestions.appendChild(li);
    });

    searchSuggestions.style.display = matches.length ? 'block' : 'none';
}

function selectSearchItem(path) {
    console.log('[Search] Selecting item:', path);
    expandPathParents(path); // ensure parent folders are open

    const target = document.querySelector(`[data-node-path='${path}']`);
    if (!target) return;

    target.scrollIntoView({ behavior: 'smooth', block: 'center' });

    // Force animation replay (even if already highlighted)
    target.classList.remove('highlighted');
    void target.offsetWidth; // Force reflow to restart animation
    target.classList.add('highlighted');

    // Remove highlight after animation completes
    setTimeout(() => {
        target.classList.remove('highlighted');
    }, 1600);

    if (!selectedItems.includes(path)) {
        selectedItems.push(path);
        console.log('[Search] Item added to selection:', selectedItems);
        onTreeSelectionChange();
    }
}

treeSearchInput.addEventListener('input', (e) => {
    const query = e.target.value.trim();
    searchTree(query);
});

treeSearchInput.addEventListener('blur', () => {
    setTimeout(() => searchSuggestions.style.display = 'none', 200);
});

/* ----------------------------------------
 * Init
 * -------------------------------------- */
console.log('[Init] DOM content loaded, initializing...');
window.addEventListener('DOMContentLoaded', loadLastActiveRepo);

------------------------------
FILE: renderer\index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Helper Tool</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="app">
    
    <!-- Top Navbar with All Controls -->
    <div class="top-navbar">

      <!-- Search Bar -->
<div class="navbar-section search-section">
  <input
    type="text"
    id="treeSearchInput"
    placeholder="Search folder/file..."
    class="search-input"
  />
  <ul id="searchSuggestions" class="search-suggestions"></ul>
</div>

      <!-- Left Section: Repo Selection -->
      <div class="navbar-section">
        <button id="selectRepoBtn" class="primary-btn">
          <span class="btn-icon">üìÅ</span>
          Select Repo
        </button>
        <span id="activeRepoName" class="repo-name">No repo selected</span>
      </div>

      <!-- Center Section: Action Buttons -->
      <div class="navbar-section center">
        <button id="structureBtn" class="action-btn">
          <span class="btn-icon">üå≥</span>
          Structure
        </button>
        <button id="codeBtn" class="action-btn">
          <span class="btn-icon">üíª</span>
          Code
        </button>
        <button id="generateBtn" class="action-btn generate-btn">
          <span class="btn-icon">‚ö°</span>
          Generate
        </button>
      </div>

      <!-- Right Section: Tools & Progress -->
      <div class="navbar-section right">
        <button id="editDocignoreBtn" class="tool-btn" title="Edit Global Ignore">
          <span class="btn-icon">‚öôÔ∏è</span>
          Ignore
        </button>
        <button id="openStorageBtn" class="tool-btn" title="Open Storage Folder">
          <span class="btn-icon">üìÇ</span>
          Storage
        </button>
        
        <!-- Progress Indicator -->
        <div class="progress-container">
          <progress id="progressBar" value="0" max="100"></progress>
          <span id="progressText">0%</span>
        </div>
      </div>
    </div>

    <!-- Tree view -->
    <div class="tree-view-container">
      <div id="treeContainer">Select a repo to view files</div>
    </div>

  </div>

  <!-- App logic -->
  <script type="module" src="app.js"></script>
</body>
</html>

------------------------------
FILE: utils\codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect files from folder respecting ignore rules
 * Skips entire ignored folders
 */
function getAllFiles(folderPath, repoRoot) {
    if (isIgnored(folderPath, repoRoot)) return [];

    if (!fs.existsSync(folderPath)) return [];

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    let files = [];

    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        if (isIgnored(fullPath, repoRoot)) continue;

        if (item.isDirectory()) files.push(...getAllFiles(fullPath, repoRoot));
        else files.push(fullPath);
    }

    return files;
}

/**
 * Find repo root starting from a folder (optional fallback)
 */
function findRepoRoot(startPath) {
    let dir = path.resolve(startPath);
    while (dir && dir !== path.parse(dir).root) {
        if (fs.existsSync(path.join(dir, '.docignore')) || fs.existsSync(path.join(dir, 'package.json'))) {
            return dir;
        }
        dir = path.dirname(dir);
    }
    return startPath; // fallback to the folder itself
}

/**
 * Generate combined code output from selected items
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}) {
    if (!selectedItems.length) return;

    const repoRoot = path.resolve(selectedItems[0]);
    await getIgnoreRules(repoRoot); // load & cache rules

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles.push(...getAllFiles(item, repoRoot));
        else if (!isIgnored(item, repoRoot)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        const relativeName = path.relative(repoRoot, filePath) || path.basename(filePath);
        writeStream.write(`\n// ===== File: ${relativeName} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }

    writeStream.close();
}

/**
 * Get folder tree structure for tree view respecting ignore rules
 * FIXED: Now properly awaits all nested folder promises
 */
async function getFolderTree(dir, repoRoot = null) {
    if (!repoRoot) repoRoot = path.resolve(dir);
    await getIgnoreRules(repoRoot);

    if (isIgnored(dir, repoRoot)) return [];

    let entries = [];
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
        return [];
    }

    // Filter out ignored entries first
    const validEntries = entries.filter(entry => 
        !isIgnored(path.join(dir, entry.name), repoRoot)
    );

    // Process all entries and await promises
    const results = await Promise.all(
        validEntries.map(async (entry) => {
            const fullPath = path.join(dir, entry.name);
            
            if (entry.isDirectory()) {
                // Recursively get children (await the promise!)
                const children = await getFolderTree(fullPath, repoRoot);
                return {
                    name: entry.name,
                    path: fullPath,
                    type: 'folder',
                    children: children,
                };
            }
            
            return { 
                name: entry.name, 
                path: fullPath, 
                type: 'file' 
            };
        })
    );

    return results;
}

module.exports = { generateCode, getAllFiles, findRepoRoot, getFolderTree };

------------------------------
FILE: utils\docignore.js

// file: docignore.js
const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch');
const { app } = require('electron');

const globalIgnorePath = path.join(app.getPath('userData'), 'global-docignore.json');

// ----------------------------
// Cached Global Rules
// ----------------------------
let cachedGlobalRules = null;
const repoRulesCache = new Map();        // repo path -> combined rules
const compiledMatchersCache = new Map(); // repo path -> compiled matcher functions

function loadGlobalIgnoreRules() {
    if (cachedGlobalRules) return cachedGlobalRules;

    if (!fs.existsSync(globalIgnorePath)) {
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }

    try {
        cachedGlobalRules = JSON.parse(fs.readFileSync(globalIgnorePath, 'utf-8'));
        console.log('[Docignore] Global ignore rules loaded:', cachedGlobalRules);
        return cachedGlobalRules;
    } catch (err) {
        console.error('[Docignore] Failed to read global ignore:', err);
        cachedGlobalRules = [];
        return cachedGlobalRules;
    }
}

// ----------------------------
// Repo-specific + combined rules (cached)
// ----------------------------
async function getIgnoreRules(repoPath) {
    if (repoRulesCache.has(repoPath)) return repoRulesCache.get(repoPath);

    let repoRules = [];
    const repoIgnoreFile = path.join(repoPath, '.docignore');

    if (fs.existsSync(repoIgnoreFile)) {
        try {
            repoRules = JSON.parse(fs.readFileSync(repoIgnoreFile, 'utf-8'));
        } catch (err) {
            console.warn('[Docignore] Failed to parse repo .docignore:', err.message);
        }
    }

    const combinedRules = [...loadGlobalIgnoreRules(), ...repoRules];
    repoRulesCache.set(repoPath, combinedRules);

    // Precompile matchers for this repo
    const matchers = combinedRules.map(pattern => micromatch.matcher(pattern, { dot: true }));
    compiledMatchersCache.set(repoPath, matchers);

    return combinedRules;
}

// ----------------------------
// Check if path is ignored
// ----------------------------
function isIgnored(fullPath, repoPath) {
    if (!repoPath) return false;

    let relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');
    if (relPath.startsWith('..')) return false;

    const matchers = compiledMatchersCache.get(repoPath) || [];
    return matchers.some(fn => fn(relPath));
}


module.exports = { isIgnored, loadGlobalIgnoreRules, getIgnoreRules };


------------------------------
FILE: utils\fileOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

async function getFolderTree(dir, repoRoot) {
    if (!repoRoot) repoRoot = path.resolve(dir);

    if (isIgnored(dir, repoRoot)) return [];

    let entries;
    try {
        entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
        return [];
    }

    const tree = [];
    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (isIgnored(fullPath, repoRoot)) continue;

        if (entry.isDirectory()) {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'folder',
                children: await getFolderTree(fullPath, repoRoot),
            });
        } else {
            tree.push({
                name: entry.name,
                path: fullPath,
                type: 'file',
            });
        }
    }

    return tree;
}

async function generateStructure(selectedPaths, outputFile, progressCallback = () => {}) {
    if (!selectedPaths?.length) return;

    const repoRoot = path.resolve(selectedPaths[0]);
    await getIgnoreRules(repoRoot); // ensures cache is populated

    async function buildTree(currentPath) {
        if (isIgnored(currentPath, repoRoot)) return null;

        let stat;
        try { stat = fs.statSync(currentPath); } catch { return null; }

        const node = {
            name: path.basename(currentPath),
            path: currentPath,
            type: stat.isDirectory() ? 'folder' : 'file',
            children: []
        };

        if (stat.isDirectory()) {
            const entries = fs.readdirSync(currentPath, { withFileTypes: true });
            for (const entry of entries) {
                const childNode = await buildTree(path.join(currentPath, entry.name));
                if (childNode) node.children.push(childNode);
            }
        }

        return node;
    }

    function treeLines(node, prefix = '', isLast = true, isRoot = true) {
        const lines = [];
        const connector = isRoot ? '' : (isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ ');
        lines.push(prefix + connector + node.name + (node.type === 'folder' ? '/' : ''));

        node.children?.forEach((child, idx) => {
            const last = idx === node.children.length - 1;
            const newPrefix = prefix + (isRoot ? '' : (isLast ? '    ' : '‚îÇ   '));
            lines.push(...treeLines(child, newPrefix, last, false));
        });

        return lines;
    }

    const allLines = [];
    for (let i = 0; i < selectedPaths.length; i++) {
        const rootNode = await buildTree(selectedPaths[i]);
        if (rootNode) allLines.push(...treeLines(rootNode));

        const percent = Math.round(((i + 1) / selectedPaths.length) * 100);
        progressCallback(percent);
    }

    try {
        fs.writeFileSync(outputFile, allLines.join('\n'), 'utf-8');
        progressCallback(100);
    } catch (err) {
        console.error('[generateStructure] Failed to write file:', err);
    }
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: utils\treeView.js

/**
 * Tree Diagram Renderer (Refactored)
 * ---------------------------------
 * - Pure render: selection comes ONLY from selectedItems
 * - No re-render on click
 * - Stable selection & expansion behavior
 */

export function renderTree(treeData, container, selectedItems, actionType, onToggle) {
    container.innerHTML = '';

    /* ----------------------------------------
     * Persistent folder expansion state
     * -------------------------------------- */
    if (!window._expandedFolders) {
        window._expandedFolders = new Map();
    }
    const expandedFolders = window._expandedFolders;

    /* ----------------------------------------
     * Helpers (PURE)
     * -------------------------------------- */

    const getAllFiles = (node) => {
        if (node.type === 'file') return [node];
        if (!node.children) return [];
        return node.children.flatMap(getAllFiles);
    };

    const countFiles = (node) => {
        if (node.type === 'file') return 1;
        if (!node.children) return 0;
        return node.children.reduce((sum, c) => sum + countFiles(c), 0);
    };

    const isSelected = (path) => selectedItems.includes(path);

    /* ----------------------------------------
     * DOM helpers
     * -------------------------------------- */

    function applySelectionClass(el, node) {
        el.classList.remove('selected', 'folder-selected', 'file-selected');

        if (!isSelected(node.path)) return;

        if (node.type === 'folder') {
            if (actionType === 'code') el.classList.add('folder-selected');
            else el.classList.add('selected');
        } else {
            el.classList.add('file-selected');
        }
    }

    function updateAllSelectionHighlights() {
        container.querySelectorAll('.tree-node').forEach(el => {
            const wrapper = el.parentElement;
            if (!wrapper?.dataset.nodePath) return;

            const path = wrapper.dataset.nodePath;
            const type = el.classList.contains('folder') ? 'folder' : 'file';

            applySelectionClass(el, { path, type });
        });

        updateGenerateState();
    }

    function updateGenerateState() {
        const btn = document.getElementById('generateBtn');
        if (btn) btn.disabled = selectedItems.length === 0;
    }

    /* ----------------------------------------
     * Node creation
     * -------------------------------------- */

    function createNode(node, depth = 0) {
        if (actionType === 'structure' && node.type === 'file') return null;

        const wrapper = document.createElement('div');
        wrapper.className = 'node-wrapper';
        wrapper.style.setProperty('--depth', depth);
        wrapper.dataset.nodePath = node.path;

        const el = document.createElement('div');
        el.classList.add('tree-node', node.type);

        /* Expansion state (folders only) */
        let expanded = expandedFolders.get(node.path);
        if (expanded === undefined && node.type === 'folder') {
            expanded = true;
            expandedFolders.set(node.path, true);
        }

        if (node.type === 'folder' && node.children?.length) {
            el.classList.add('expandable');
            if (expanded) el.classList.add('folder-open');
        }

        /* Label */
        let label = node.name;

        if (node.type === 'folder' && node.children?.length && actionType !== 'structure') {
            const count = countFiles(node);
            if (count > 0) label += ` (${count})`;
        }

        if (node.type === 'folder' && actionType === 'code' && isSelected(node.path)) {
            label += ' [ALL]';
        }

        el.textContent = label;
        applySelectionClass(el, node);

        wrapper.appendChild(el);

        /* Children */
        let childrenContainer = null;

        if (node.type === 'folder' && node.children?.length) {
            childrenContainer = document.createElement('div');
            childrenContainer.className = 'children';
            if (!expanded) childrenContainer.style.display = 'none';

            node.children.forEach(child => {
                const childEl = createNode(child, depth + 1);
                if (childEl) {
                    childrenContainer.appendChild(childEl);
                }
            });



            wrapper.appendChild(childrenContainer);
        }

        /* ----------------------------------------
         * Click handling (STATE ONLY)
         * -------------------------------------- */
        el.addEventListener('click', (e) => {
            e.stopPropagation();

            if (node.type === 'file') {
                togglePath(node.path);
            } else {
                if (actionType === 'code') {
                    const files = getAllFiles(node);
                    const allSelected = files.every(f => isSelected(f.path));

                    files.forEach(f => {
                        if (allSelected) removePath(f.path);
                        else addPath(f.path);
                    });
                } else {
                    togglePath(node.path);
                }

                if (node.children?.length) {
                    expanded = !expanded;
                    expandedFolders.set(node.path, expanded);

                    if (childrenContainer) {
                        childrenContainer.style.display = expanded ? 'flex' : 'none';
                    }

                    el.classList.toggle('folder-open', expanded);
                }
            }

            updateAllSelectionHighlights();
            onToggle?.(node);
        });

        return wrapper;
    }

    /* ----------------------------------------
     * Selection mutations (CENTRALIZED)
     * -------------------------------------- */

    function addPath(path) {
        if (!selectedItems.includes(path)) selectedItems.push(path);
    }

    function removePath(path) {
        const i = selectedItems.indexOf(path);
        if (i !== -1) selectedItems.splice(i, 1);
    }

    function togglePath(path) {
        if (isSelected(path)) removePath(path);
        else addPath(path);
    }

    /* ----------------------------------------
     * Initial render
     * -------------------------------------- */

    const root = document.createElement('div');
    root.className = 'tree-root';

    treeData.forEach(node => {
        const el = createNode(node, 0);
        if (el) root.appendChild(el);
    });

    container.appendChild(root);
    updateGenerateState();
}


