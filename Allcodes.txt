------------------------------
FILE: config\config.js

const fs = require('fs');
const path = require('path');
const { app } = require('electron');

const CONFIG_PATH = path.join(__dirname, 'helper-config.json');

function readConfig() {
    if (!fs.existsSync(CONFIG_PATH)) {
        const defaultConfig = {
            baseStoragePath: path.join(app.getPath('userData'), 'HelperToolStorage'),
            activeProject: null,
            projects: {},
            preferences: {
                docignoreFileName: ".docignore",
                showHiddenFiles: false,
                defaultStructureView: "tree",
                autoSelectLastProject: true
            }
        };
        fs.writeFileSync(CONFIG_PATH, JSON.stringify(defaultConfig, null, 2));
        return defaultConfig;
    }
    return JSON.parse(fs.readFileSync(CONFIG_PATH));
}

function writeConfig(config) {
    fs.writeFileSync(CONFIG_PATH, JSON.stringify(config, null, 2));
}

function getActiveProject() {
    const config = readConfig();
    if (config.activeProject) {
        return config.projects[config.activeProject];
    }
    return null;
}

function getLastSelectedItems() {
    const project = getActiveProject();
    return project?.lastSelectedItems || [];
}

function setLastSelectedItems(items) {
    const cfg = readConfig();
    if (cfg.activeProject && cfg.projects[cfg.activeProject]) {
        cfg.projects[cfg.activeProject].lastSelectedItems = items;
        writeConfig(cfg);
    }
}

function ensureStorageFolder(storagePath) {
    if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
    ['Codes', 'Structures'].forEach(sub => {
        const subPath = path.join(storagePath, sub);
        if (!fs.existsSync(subPath)) fs.mkdirSync(subPath);
    });
    return storagePath;
}

module.exports = { 
    readConfig, 
    writeConfig, 
    getActiveProject, 
    getLastSelectedItems,
    setLastSelectedItems,
    ensureStorageFolder
};


------------------------------
FILE: config\helper-config.json

{
  "baseStoragePath": "C:/Users/Windows10/Desktop/HelperToolStorage",
  "activeProject": "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown",
  "projects": {
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Projects\\EduTool\\client\\src": {
      "storageName": "src",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\src",
      "lastUsed": "2026-01-05T10:06:31.639Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\backend": {
      "storageName": "backend",
      "storagePath": "C:\\Users\\Windows 10\\Documents\\HelperStorage\\backend",
      "lastUsed": "2026-01-05T10:06:54.589Z"
    },
    "C:\\Users\\Windows 10\\Desktop\\Parallel\\Guitar-store": {
      "storageName": "Guitar-store",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Guitar-store",
      "lastUsed": "2026-01-05T10:34:07.131Z",
      "lastSelectedItems": []
    },
    "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown": {
      "storageName": "Gown",
      "storagePath": "C:\\Users\\Windows 10\\AppData\\Roaming\\Electron\\Gown",
      "lastUsed": "2026-01-05T11:02:54.764Z",
      "lastSelectedItems": [
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown\\database",
        "C:\\Users\\Windows 10\\Desktop\\Personal\\Gown\\server\\database"
      ]
    }
  },
  "preferences": {
    "docignoreFileName": ".docignore",
    "showHiddenFiles": false,
    "defaultStructureView": "tree",
    "autoSelectLastProject": true
  }
}

------------------------------
FILE: main.js

const { app, BrowserWindow, Tray, Menu, ipcMain, shell, dialog } = require('electron');
const path = require('path');
const fs = require('fs');
const config = require('./config/config.js');

// Utils
const fileOps = require('./utils/fileOps.js');
const docignoreUtils = require('./utils/docignore.js');
const codeOps = require('./utils/codeOps.js');

let mainWindow;
let tray;

function createWindow() {
    mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        show: true,
        webPreferences: {
            preload: path.join(__dirname, 'preload.js')
        }
    });

    mainWindow.loadFile(path.join(__dirname, 'renderer', 'index.html'));
    mainWindow.on('close', (e) => {
        e.preventDefault();
        mainWindow.hide();
    });
}

app.whenReady().then(() => {
    createTray();
    createWindow();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });
});

function createTray() {
    tray = new Tray(path.join(__dirname, 'assets', 'tray-icon.png'));
    const contextMenu = Menu.buildFromTemplate([
        { label: 'Open Helper', click: () => mainWindow.show() },
        { label: 'Open Storage Folder', click: () => openStorage() },
        { type: 'separator' },
        { label: 'Select Previous Repo', submenu: getPreviousReposMenu() },
        { type: 'separator' },
        { label: 'Exit', click: () => app.quit() }
    ]);
    tray.setToolTip('Helper Tool');
    tray.setContextMenu(contextMenu);
}

function getPreviousReposMenu() {
    const cfg = config.readConfig();
    const submenu = [];

    for (const repoPath in cfg.projects) {
        submenu.push({
            label: path.basename(repoPath),
            click: () => {
                cfg.activeProject = repoPath;
                config.writeConfig(cfg);
            }
        });
    }

    if (submenu.length === 0) {
        submenu.push({ label: 'No previous repos', enabled: false });
    }

    return submenu;
}

function openStorage() {
    const activeProject = config.getActiveProject();
    if (activeProject) {
        const storagePath = activeProject.storagePath;
        if (fs.existsSync(storagePath)) {
            shell.openPath(storagePath);
        } else {
            dialog.showErrorBox('Storage Not Found', 'Storage folder does not exist.');
        }
    } else {
        dialog.showErrorBox('No Active Project', 'Select a project first.');
    }
}

/* ===========================
   IPC Handlers
=========================== */

// 1️⃣ Select repo (updated to use userData storage)
ipcMain.handle('select-repo', async () => {
    const result = await dialog.showOpenDialog({
        properties: ['openDirectory']
    });

    if (result.canceled || !result.filePaths.length) return null;
    const repoPath = result.filePaths[0];

    const cfg = config.readConfig();
    const storageName = path.basename(repoPath).replace(/[^a-zA-Z0-9-_]/g, '_');

    // Save inside Electron userData folder
    const userDataPath = app.getPath('userData');
    const storagePath = path.join(userDataPath, storageName);

    try {
        // Ensure base folder exists
        if (!fs.existsSync(userDataPath)) fs.mkdirSync(userDataPath, { recursive: true });
        // Ensure storage folder and subfolders exist
        if (!fs.existsSync(storagePath)) fs.mkdirSync(storagePath, { recursive: true });
        ['Codes', 'Structures'].forEach(sub => {
            const subPath = path.join(storagePath, sub);
            if (!fs.existsSync(subPath)) fs.mkdirSync(subPath, { recursive: true });
        });
    } catch (err) {
        dialog.showErrorBox('Permission Error', `Cannot create storage folder:\n${storagePath}\n\n${err.message}`);
        return null;
    }

    // Add or update project in config
    cfg.projects[repoPath] = {
        storageName,
        storagePath,
        lastUsed: new Date().toISOString()
    };

    // Set active project
    cfg.activeProject = repoPath;
    config.writeConfig(cfg);

    return repoPath;
});

// 2️⃣ Get folder tree
ipcMain.handle('getFolderTree', async (event, repoPath) => {
    if (!repoPath) return [];

    const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);
    return fileOps.getFolderTree(repoPath, ignoreRules);
});

// 3️⃣ Generate structure/code
ipcMain.handle('generate', async (event, actionType, repoPath, items, fileName) => {
    if (!repoPath || !items.length || !fileName) return;

    const activeProject = config.getActiveProject();
    if (!activeProject) {
        dialog.showErrorBox('Error', 'No active project found in config.');
        return;
    }

    const storagePath = activeProject.storagePath;
    const outputFolder = actionType === 'code'
        ? path.join(storagePath, 'Codes')
        : path.join(storagePath, 'Structures');

    if (!fs.existsSync(outputFolder)) fs.mkdirSync(outputFolder, { recursive: true });

    const outputFile = path.join(outputFolder, fileName);
    const ignoreRules = await docignoreUtils.getIgnoreRules(repoPath);

    if (actionType === 'structure') {
        await fileOps.generateStructure(items, outputFile, ignoreRules, (percent) => {
            mainWindow.webContents.send('progress-update', percent);
        });
    } else if (actionType === 'code') {
        await codeOps.generateCode(items, outputFile, (percent) => {
            mainWindow.webContents.send('progress-update', percent);
        }, repoPath, ignoreRules);
    }

    return true;
});

// 4️⃣ Get .docignore rules
ipcMain.handle('get-docignore', async (event, repoPath) => {
    if (!repoPath) return [];
    return await docignoreUtils.getIgnoreRules(repoPath);
});

ipcMain.handle('get-active-project', () => {
    const activeProjectPath = config.readConfig().activeProject; // this is the real repo folder
    if (!activeProjectPath) return null;

    const projectData = config.readConfig().projects[activeProjectPath];
    return {
        repoPath: activeProjectPath,    // <-- real folder path
        ...projectData
    };
});


// ✅ IPC: get last selected items
ipcMain.handle('get-last-selected', () => {
    return config.getLastSelectedItems();
});

// ✅ IPC: save last selected items
ipcMain.handle('set-last-selected', (event, items) => {
    config.setLastSelectedItems(items);
});


------------------------------
FILE: preload.js

const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
    selectRepo: () => ipcRenderer.invoke('select-repo'),
    getFolderTree: (repoPath) => ipcRenderer.invoke('getFolderTree', repoPath),
    generate: (actionType, repoPath, items, fileName, onProgress) => {
        return ipcRenderer.invoke('generate', actionType, repoPath, items, fileName)
            .then(() => { if (onProgress) onProgress(100); });
    },
    openStorage: () => ipcRenderer.invoke('open-storage'),
    onProgressUpdate: (callback) => ipcRenderer.on('progress-update', (event, percent) => callback(percent)),
    getDocignore: (repoPath) => ipcRenderer.invoke('get-docignore', repoPath),
    getLastSelected: () => ipcRenderer.invoke('get-last-selected'),
    setLastSelected: (items) => ipcRenderer.invoke('set-last-selected', items),
    getActiveProject: () => ipcRenderer.invoke('get-active-project')
});


------------------------------
FILE: renderer\app.js

const selectRepoBtn = document.getElementById('selectRepoBtn');
const activeRepoName = document.getElementById('activeRepoName');
const treeContainer = document.getElementById('treeContainer');
const structureBtn = document.getElementById('structureBtn');
const codeBtn = document.getElementById('codeBtn');
const generateBtn = document.getElementById('generateBtn');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

let selectedRepoPath = null;
let selectedItems = [];
let actionType = 'code';

treeContainer.style.overflowY = 'auto';
treeContainer.style.maxHeight = '80vh';

window.electronAPI.onProgressUpdate((percent) => {
    progressBar.value = percent;
    progressText.textContent = `${percent}%`;
});

function updateActiveRepo(name) {
    activeRepoName.textContent = name || 'No repo selected';
}

async function loadLastActiveRepo() {
    const lastRepoPath = await window.electronAPI.getActiveProjectPath?.();
    if (!lastRepoPath) return;

    await loadRepo(lastRepoPath);
}

selectRepoBtn.addEventListener('click', async () => {
    const repoPath = await window.electronAPI.selectRepo();
    if (!repoPath) return;
    await loadRepo(repoPath);
});

async function loadRepo(repoPath) {
    selectedRepoPath = repoPath;
    const repoName = repoPath.split(/[/\\]/).pop();
    updateActiveRepo(repoName);
    const treeData = await window.electronAPI.getFolderTree(repoPath);

    selectedItems = await window.electronAPI.getLastSelected();

    displayTree(treeData, treeContainer, actionType);
}

function displayTree(tree, container, mode) {
    container.innerHTML = '';

    function createNode(node) {
        if (mode === 'structure' && node.type === 'file') return null;

        const el = document.createElement('div');
        el.classList.add('tree-node');
        el.style.cursor = 'pointer';
        el.style.paddingLeft = '16px';
        el.style.userSelect = 'none';
        el.style.fontSize = '14px';

        if (node.type === 'file') el.classList.add('file');
        if (selectedItems.includes(node.path)) el.classList.add('selected');

        if (
    selectedItems.includes(node.path) &&
    node.type === 'folder' &&
    actionType === 'code'
) {
    el.classList.add('folder-selected');
}


        let label = node.name;
        if (node.type === 'folder' && node.children?.length > 0 && mode !== 'structure') {
            const fileCount = countFiles(node);
            if (fileCount > 0) label += ` (${fileCount} files)`;
        }
        if (
    node.type === 'folder' &&
    actionType === 'code' &&
    selectedItems.includes(node.path)
) {
    label += ' [ALL FILES]';
}

el.textContent = label;


        el.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSelect(el, node);
        });

        if (node.type === 'folder' && node.children?.length > 0) {
            const childrenContainer = document.createElement('div');
            childrenContainer.classList.add('children');
            childrenContainer.style.marginLeft = '16px';
            node.children.forEach(child => {
                const childNode = createNode(child);
                if (childNode) childrenContainer.appendChild(childNode);
            });
            el.appendChild(childrenContainer);
        }

        return el;
    }

    tree.forEach(node => {
        const n = createNode(node);
        if (n) container.appendChild(n);
    });
}

function countFiles(node) {
    if (node.type === 'file') return 1;
    if (!node.children?.length) return 0;
    return node.children.reduce((acc, child) => acc + countFiles(child), 0);
}

function toggleSelect(el, node) {
    const isSelected = selectedItems.includes(node.path);
generateBtn.disabled = selectedItems.length === 0;
    if (isSelected) {
        selectedItems = selectedItems.filter(p => p !== node.path);
        el.classList.remove('selected');
        el.classList.remove('folder-selected');
    } else {
        selectedItems.push(node.path);
        el.classList.add('selected');

        if (node.type === 'folder' && actionType === 'code') {
            el.classList.add('folder-selected');
        }
    }

   window.electronAPI.setLastSelected(selectedItems);

if (node.type === 'folder' && actionType === 'code') {
    window.electronAPI.getFolderTree(selectedRepoPath)
        .then(tree => displayTree(tree, treeContainer, actionType));
}

}

function resetSelection() {
    selectedItems = [];
    window.electronAPI.setLastSelected([]);
}generateBtn.disabled = true;


structureBtn.addEventListener('click', async () => {
    actionType = 'structure';
    resetSelection();

    if (!selectedRepoPath) return;

    const treeData = await window.electronAPI.getFolderTree(selectedRepoPath);
    displayTree(treeData, treeContainer, actionType);
});



codeBtn.addEventListener('click', async () => {
    actionType = 'code';
    resetSelection();

    if (!selectedRepoPath) return;

    const treeData = await window.electronAPI.getFolderTree(selectedRepoPath);
    displayTree(treeData, treeContainer, actionType);
});



generateBtn.addEventListener('click', async () => {
    if (!selectedRepoPath || !selectedItems.length) return alert('Select repo and items first!');
    const fileName = prompt('Enter output file name (e.g., UserModule.txt):');
    if (!fileName) return;

    progressBar.value = 0;
    progressText.textContent = '0%';

    await window.electronAPI.generate(actionType, selectedRepoPath, selectedItems, fileName);

    alert('Done!');
    selectedItems = [];
    const treeData = await window.electronAPI.getFolderTree(selectedRepoPath);
    displayTree(treeData, treeContainer, actionType);
});

// ✅ Only one DOMContentLoaded
window.addEventListener('DOMContentLoaded', loadLastActiveRepo);


------------------------------
FILE: utils\codeOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored, getIgnoreRules } = require('./docignore');

/**
 * Recursively collect all file paths from a folder, respecting ignore rules
 */
function getAllFiles(folderPath, ignoreRules = [], repoRoot) {
    let files = [];
    if (!fs.existsSync(folderPath)) return files;

    const items = fs.readdirSync(folderPath, { withFileTypes: true });
    for (const item of items) {
        const fullPath = path.join(folderPath, item.name);

        if (isIgnored(fullPath, repoRoot, ignoreRules)) continue;

        if (item.isDirectory()) {
            files = files.concat(getAllFiles(fullPath, ignoreRules, repoRoot));
        } else if (item.isFile()) {
            files.push(fullPath);
        }
    }

    return files;
}

/**
 * Generate code file by combining multiple selected folders/files
 * @param {Array<string>} selectedItems - files or folders
 * @param {string} outputFile
 * @param {Function} onProgress - callback(percent)
 * @param {string} repoRoot - repo root path
 * @param {Array<string>} ignoreRules - optional ignore rules
 */
async function generateCode(selectedItems, outputFile, onProgress = () => {}, repoRoot, ignoreRules = []) {
    if (!selectedItems.length) return;
    if (!repoRoot) repoRoot = path.dirname(selectedItems[0]);
    if (!ignoreRules.length) ignoreRules = await getIgnoreRules(repoRoot);

    let allFiles = [];
    for (const item of selectedItems) {
        const stat = fs.statSync(item);
        if (stat.isDirectory()) allFiles = allFiles.concat(getAllFiles(item, ignoreRules, repoRoot));
        else if (stat.isFile() && !isIgnored(item, repoRoot, ignoreRules)) allFiles.push(item);
    }

    if (!allFiles.length) return;

    const writeStream = fs.createWriteStream(outputFile, { flags: 'w', encoding: 'utf-8' });
    for (let i = 0; i < allFiles.length; i++) {
        const filePath = allFiles[i];
        writeStream.write(`\n// ===== File: ${path.relative(repoRoot, filePath)} =====\n`);
        writeStream.write(fs.readFileSync(filePath, 'utf-8') + '\n');
        onProgress(Math.round(((i + 1) / allFiles.length) * 100));
    }
    writeStream.close();
}


module.exports = {
    generateCode
};


------------------------------
FILE: utils\docignore.js

const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch'); // npm install micromatch

/**
 * Read .docignore file from repo
 * @param {string} repoPath - path to the repo
 * @returns {Promise<string[]>} - array of patterns to ignore
 */
async function getIgnoreRules(repoPath) {
    const cfg = path.join(repoPath, '.docignore');
    if (!fs.existsSync(cfg)) return [];
    return fs.readFileSync(cfg, 'utf-8')
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l && !l.startsWith('#'));
}


/**
 * Check if a given file/folder path should be ignored
 * @param {string} fullPath - absolute path of file/folder
 * @param {string} repoPath - root repo path
 * @param {Array<string>} ignoreRules - array of patterns from getIgnoreRules
 * @returns {boolean}
 */
function isIgnored(fullPath, repoPath, ignoreRules) {
    const relPath = path.relative(repoPath, fullPath).replace(/\\/g, '/');
    return micromatch.isMatch(relPath, ignoreRules, { dot: true });
}
module.exports = { getIgnoreRules, isIgnored };


------------------------------
FILE: utils\fileOps.js

const fs = require('fs');
const path = require('path');
const { isIgnored } = require('./docignore');

function getFolderTree(dir, ignoreRules = [], repoRoot = dir) {
    return fs.readdirSync(dir, { withFileTypes: true })
        .filter(f => !isIgnored(path.join(dir, f.name), repoRoot, ignoreRules))
        .map(f => f.isDirectory()
            ? { name: f.name, path: path.join(dir, f.name), type: 'folder', children: getFolderTree(path.join(dir, f.name), ignoreRules, repoRoot) }
            : { name: f.name, path: path.join(dir, f.name), type: 'file' }
        );
}

async function generateStructure(selectedPaths, outputFile, ignoreRules = [], progressCallback = () => {}) {
    let output = '';
    const allItems = [];

    function collect(p, repoRoot) {
        if (isIgnored(p, repoRoot, ignoreRules)) return;
        allItems.push(p);
        if (fs.statSync(p).isDirectory())
            fs.readdirSync(p).forEach(c => collect(path.join(p, c), repoRoot));
    }

    selectedPaths.forEach(p => collect(p, p));

    allItems.forEach((p, idx) => {
        const stat = fs.statSync(p);
        output += `${'  '.repeat(p.split(path.sep).length)}${path.basename(p)}${stat.isDirectory() ? '/' : ''}\n`;
        progressCallback(Math.round(((idx + 1) / allItems.length) * 100));
    });

    fs.writeFileSync(outputFile, output, 'utf-8');
}

module.exports = { getFolderTree, generateStructure };


------------------------------
FILE: utils\treeView.js



